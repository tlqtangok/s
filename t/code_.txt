**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



///////////////////////
**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



//////////
// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

     
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();
     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    
   

    return -1; 

    //////////////////////////////////

void clear_img_corner(Mat & id_m){

    for (int i=0;i<id_m.rows/4;i++){
        for(int j=0;j<id_m.cols/3;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=255; 

            }
        }
    }

}

int _tmain(int argc, char** argv)
{


// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
  /*
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

    */ 
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();



     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    

    // clear_img_corner( id_mm ); 

     
     id_mm= id_mm.t();

   imshow("imshow", id_mm ); 
   waitKey(0);


    return -1; 

    //////////////////////////////////
imwrite("test.bmp", id_t); 

int _tmain(int argc, char** argv)
{

    Mat id_t = Mat::zeros(444,444, CV_8UC(1)); 


    int x = 999;
    char buf[111]={0};
    sprintf_s(buf, "%d", x);

    

    putText( id_t, string(buf), Point(id_t.cols/2,id_t.rows/2), 1, 1, Scalar(255) ); 


   // imshow( "id_t", id_t); 

   // imwrite("test.bmp", id_t); 

    int id = 9; 
    id_map[id] = id_t ; 
    id_map[id+1] = id_t; 
    for ( auto tt : id_map ){
    tt.first; 
    auto id_x = tt.second;

    imshow( "id_x", id_x);
    cv::waitKey(0);
    
    }


    



    return -1; 

    //////////////////////////////////
    Mat id_m = imread( "x:\\test_small_50.bmp");
    Mat id_dst_m; 
resize( id_m, id_dst_m, Size(id_m.cols, id_m.rows*(1+3.5/100)), 0, 0, INTER_LINEAR);

Mat id_mm(id_m, Range(1,id_m.rows-20), Range::all()); 
uchar* from_mat_2_pdata(uchar* pData, Mat& id_mt){

    int i=0;
    int j=0;

    int rows_ = id_mt.rows; 
    int cols_ = id_mt.cols;
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            pData[cnt++] = t[0]; 
        }
    }


    return pData;

}

Mat from_pdata_2_mat(uchar* pData, int rows_, int cols_){
    Mat id_mt(rows_, cols_, CV_8UC(1));
    int i=0; int j=0 ; 
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            t[0] = pData[cnt++]; 
        }
    }

    return id_mt;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  int to_cut_bottom_len){

    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);


    Mat id_mm(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_bottom_len)); 
    Mat id_dst_m; 
    resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, INTER_LINEAR);

    from_mat_2_pdata(pData, id_dst_m); 
    return pData;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  bool is_cut_cols_, int to_cut_len){


    double Time = (double)cvGetTickCount();
// ?㷨????





    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);
    Mat id_mm; 
    Mat id_dst_m; 
/*
    enum
{
    INTER_NEAREST=CV_INTER_NN, //!< nearest neighbor interpolation
    INTER_LINEAR=CV_INTER_LINEAR, //!< bilinear interpolation
    INTER_CUBIC=CV_INTER_CUBIC, //!< bicubic interpolation
    INTER_AREA=CV_INTER_AREA, //!< area-based (or super) interpolation
    INTER_LANCZOS4=CV_INTER_LANCZOS4, //!< Lanczos interpolation over 8x8 neighborhood
    INTER_MAX=7,
    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP
};
*/

    
    int interop_way = INTER_NEAREST;
    if ( is_cut_cols_ ){
        
        id_mm = Mat(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_len)); 
         resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }
    else {
        id_mm = Mat(id_mt, Range(0,id_mt.rows-to_cut_len), Range(0,id_mt.cols)); 
        resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }

   
    from_mat_2_pdata(pData, id_dst_m); 

    Time = (double)cvGetTickCount() - Time ;

    printf( "run time = %gms\n", Time /(cvGetTickFrequency()*1000) );//????
    return pData;
}



Mat  read_bmp_and_T(string str_fn){
    Mat id_m = imread(str_fn); 
    return id_m.t(); 
}


#include <thread>
#include <mutex>
#include <iostream>
using namespace std;
mutex g_mutex;
int g_count = 0;
int main()
{
#if 0
{
std::unique_lock <std::mutex > lock(mtx);
// do something 
lock.unlock();  
}


#endif 
	thread thr1([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 10;
			}
			});
	thread thr2([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 20;
			}
			});
	thr1.join();
	thr2.join();
	cout << g_count << endl;
}
 
*********************
test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
using namespace std;
void fun1(int n) //??ʼ?????캯??
{
	cout << "Thread " << n << " executing\n";
	n += 10;
	this_thread::sleep_for(chrono::milliseconds(10));
}
void fun2(int & n) //???????캯??
{
	cout << "Thread " << n << " executing\n";
	n += 20;
	this_thread::sleep_for(chrono::milliseconds(10));
}
int main()
{
	int n = 0;
	thread t1; //t1????һ??thread
	thread t2(fun1, n + 1); //????ֵ????
	t2.join();
	cout << "n=" << n << '\n';
	n = 10;
	thread t3(fun2, ref(n)); //????
	thread t4(move(t3)); //t4ִ??t3??t3????thread
	t4.join();
	cout << "n=" <<n << endl;
       	return 0;
}

*********************
compile_by_arm_g++.sh
*********************
ARM_GCC_ROOT=/home/cross/imx6qplus/gcc/gcc-linaro-arm-linux-gnueabihf-4.8-2014.04_linux
#arm-linux-gnueabihf  bin  lib  libexec  share
alias arm_gcc=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-gcc
alias arm_g++=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-g++

THIRD_PARTY_DIR=/home/cross/imx6qplus/third_libs_imx6qp
OPENCV_INC=${THIRD_PARTY_DIR}/include
LIB_DIR=${THIRD_PARTY_DIR}/lib
LIB_DIR_QT=/home/cross/imx6qplus/QT/lib
 NAME_OF_LIBS="-lopencv_calib3d -lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lopencv_nonfree -lopencv_objdetect -lopencv_photo -lopencv_stitching -lopencv_superres -lopencv_video -lopencv_videostab"
#export LD_LIBRARY_PATH=${LIB_DIR}:${LIB_DIR_QT}:$LD_LIBRARY_PATH

arm_g++ -std=c++11  -pthread -Wl,-no-as-needed test.cpp  -I${OPENCV_INC} -L${LIB_DIR_QT}  -L${LIB_DIR} 


EOF

//get cpu number
#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
#include<iostream>
#include<thread>
using namespace std;
int main()
{
        auto n = thread::hardware_concurrency();//??ȡcpu???ĸ???
        cout << n << endl;
        return 0;
}


*********************
/home/tanglq/t/test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
atomic_int num{0};

const int N = 100000;

void run()
{
	for (int i = 0; i < N; i++)
	{
		num++;
	}
}
int main()
{
	clock_t start = clock();
	thread t1(run);
	thread t2(run);
	t1.join();
	t2.join();
	clock_t end = clock();
	cout << "num=" << num << ",??ʱ " << end - start << " ms" << endl;
	return 0;
}

EOF


	auto fun = [](){
	cout << "lambda fun()\n"; 
	};  // must have a semicolon here 

	fun();

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
atomic_int num{0};

const int N = 10000000;

void run()
{

	for (int i = 0; i < N; i++)
	{
		num++;
	}
}

int main()
{
// lambda + this_thread 
	thread th1([]() {
			//???̵߳ȴ?3??
			this_thread::sleep_for(chrono::seconds(3));
			//??cpuִ?????????е??߳?
			this_thread::yield();
			//?߳?id
			cout << this_thread::get_id() << endl;
			});

	th1.join();
	return 0;


}


   int a = 9; 
   int b = 88; 
   swap(a,b); 

*********************
/home/tanglq/t/test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
#include<cstdarg>
#include <Windows.h>
#include <stdio.h>
using namespace std;



using namespace std;




void thread01()
{
	for (int i = 0; i < 5; i++)
	{
		cout << "Thread 01 is working ??" << endl;
		Sleep(100);
	}
}
void thread02()
{
	for (int i = 0; i < 5; i++)
	{
		cout << "Thread 02 is working ??" << endl;
		Sleep(200);
	}
}
int main()
{
	thread task01(thread01);
	thread task02(thread02);
	task01.detach();
	task02.detach();
	for (int i = 0; i < 5; i++)
	{
		cout << "Main thread is working ??" << endl;
		Sleep(200);
	}
	return 0;
}


EOF

iplimage struct


void print_iplimage(IplImage* img){

    int rows = img->height;
    int cols = img->width; 
    int step = img->widthStep; 
    for ( int i = 0; i< rows; i++)
    {
        for ( int j = 0; j< cols; j++)
        {
            uchar t = CV_IMAGE_ELEM( img, uchar,  i, j ); 
            printf("%d ", t); 
        }
        cout << "\n"; 
    }
};


int _tmain(int argc, char** argv)
{

    int rows = 5;
    int cols = 5; 
    int step = cols; 

    auto id_m_header = cvCreateImageHeader(cvSize(cols, rows), 8, 1);   // mem 0 
    char *pdata_r0 = new char[ rows * step ];  // mem 2
    char *pdata = pdata_r0; 
    id_m_header->imageData = pdata; 
    delete [] pdata_r0;  // rel 2
    cvReleaseImageHeader( &id_m_header );  // rel 0 





    IplImage *img = cvCreateImage( cvSize(cols,rows), 8, 1 );  // mem 1

    rows = img->height;
    cols = img->width; 
    step = img->widthStep; 

    int id_row = 1; 
    int id_col = 1; 
    auto& t = (img->imageData[id_row * step + id_col]) ;
    t = 111; 

    uchar get_e_t = CV_IMAGE_ELEM(img, uchar , id_row, id_col); 
    print_iplimage( img ); 

   
    cvReleaseImage(&img); // rel 1

    __P__; // system("pause");
    return 0;
} // end main()






///////


void print_iplimage(IplImage* img){

    int rows = img->height;
    int cols = img->width; 
    int step = img->widthStep; 
    for ( int i = 0; i< rows; i++)
    {
        for ( int j = 0; j< cols; j++)
        {
            uchar t = CV_IMAGE_ELEM( img, uchar,  i, j ); 
            printf("%d ", t); 
        }
        cout << "\n"; 
    }
};


int _tmain(int argc, char** argv)
{
    int r = 40; 
    int c = 40;

    IplImage * id_mm = cvCreateImage( cvSize(c,r), 8, 1 ); 
    CV_IMAGE_ELEM( id_mm, uchar, id_mm->height/2, id_mm->width/2) = 0; 
    cvNamedWindow( "fileName");
    cvShowImage( "fileName", id_mm );
    cvSaveImage("filename.bmp",id_mm);
    cvWaitKey(1);

    IplImage* id_mmm = cvCloneImage( id_mm ); 
    cvReleaseImage( &id_mm ); 



    // only have id_mmm
    CvMat *subMat = cvCreateMat( id_mmm->height/2, id_mmm->width/2, CV_8UC1); 
    cvGetSubRect(id_mmm, subMat, cvRect(0, 0, id_mmm->height/2,id_mmm->width/2));
    cvReleaseMat( &subMat );

    cvReleaseImage( &id_mmm );


    // only get id_m
    CvMat* id_m = cvCreateMat(2, 4, CV_32FC1);  // mem 0 
    cvmSet( id_m, 1,1, 5.99f); 
    cvmGet( id_m, 1,1 ); 
    auto sz_id_m = cvGetSize( id_m ); sz_id_m.width; sz_id_m.height; 

    //cvZero( id_m );
    double t = cvmGet( id_m, 1 ,1); 
    printf("%f\n", t); 


    cvReleaseMat( &id_m ); // rel 0


    CvScalar id_rgb     = CV_RGB(255,255,255); 		// cv rgb 
    //cout << id_rgb.val[0] << endl; 


    __P__; // system("pause");
    return 0;
} // end main()






///////
// iplimage open image and show img 
void show_iplimg(IplImage *img){

    cvNamedWindow("tmp_win" ); 

    cvShowImage( "tmp_win", img);
    cvWaitKey();
    return;
};

int _tmain(int argc, char** argv)
{
    IplImage* pImg = cvLoadImage( "filename.bmp", 0);

    show_iplimg( pImg ); 

    __P__; // system("pause");
    return 0;
} // end main()


// multiple channel image read and write
    int rows = id_m->height;
    int cols = id_m->width; 
    int step = id_m->widthStep;
    int c = id_m->nChannels;
    for( int i=0;i<rows/2;i++){
        for( int j=0;j<cols/2;j++){

            for(int k=0;k<c;k++){
                auto& t = id_m->imageData[i*step + j*c + k];
                t = 0; 
            }

        }
    }
//////////// sigint SIGINT ///////////
// bld
//gcc test.c -o test.exe -l pthread
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#define true 1
void * One(void * no)
{
        while (true)
        {
                printf("NUAACS1\n");
                sleep(1);
        }
}
void * Two(void * no)
{
        while (true)
        {
                printf("NUAACS2\n");
                sleep(1);
        }
}
void Stop(int signo)
{
        printf("oops! stop!!!\n");
        _exit(0);
}
int main()
{
        int res;
        pthread_t A, B;
        signal(SIGINT, Stop);
        res = pthread_create(&A, NULL, One, NULL);
        res = pthread_create(&B, NULL, Two, NULL);
        res = pthread_join(A, NULL);
        res = pthread_join(B, NULL);
        return 0;
}

// cmd system buf 
// char len 
// sigint
int run_cmd(char* cmd, char *res){
        FILE *pf = popen(cmd, "r");
        const int TO_READ_SZ = 1023;
        if ( 0 != fread(res,TO_READ_SZ, 1, pf)){
                printf( "- cannot run system cmd %s\n", cmd ); 
                return -1; 
        } ;
        pclose(pf);
        return 0;
}
void stop_in_sig_int(){
        fclose(fp);
        printf( "\n- meet ctrl+c \n");
        _exit(0);

}
int main(int argc, char *argv[])
{  

        signal(SIGINT,stop_in_sig_int);

        int retval = -1;
        double cur_value;
        double high_value;
        cur_value = 0.0;
        high_value = 0.0;
        char buf[1024] = {0};
        run_cmd( "date \"+%Y%m%d_%H%M\" ", buf ); 
        printf( "%s", buf ); 

        char buf_fn[1024] ={0};
        sprintf( buf_fn, "temp_log_%s", buf); 
        buf_fn[strlen("temp_log_20170406_xxxx")] = '\0';
        fp = fopen(buf_fn, "a+");
        while (1)
        {
                retval =get_cpu_temperature("coretemp-isa-0000", &cur_value, &high_value);
                fprintf(fp, "cur_value=%f,high_value=%f\n",cur_value,high_value);
                printf( "cur_value=%f,high_value=%f\n",cur_value,high_value);
                sleep(5);
        }
        fclose( fp ); 
        return retval;
}

date --set="2017-06-08 14:51"
// set time and date by time STRING string 
// linux SIGALAM timer alarm usage 
// ////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
int sec;
const int BUF_TIME_MAX  = 256; 
char buf_time[BUF_TIME_MAX] = {0};

int run_cmd(char* cmd, char *res);

char* get_now(int flag_print=0){
        run_cmd( (char*)"date \"+%Y%m%d_%H%M : %S\" ", buf_time );
        if(flag_print){
                printf( "%s\n", buf_time);
        }
        return buf_time;
}
void sigroutine(int signo){
        get_now(1); 
        switch (signo){
                case SIGALRM:
                        printf("Catch a signal -- SIGALRM \n");
                        //                      signal(SIGALRM, sigroutine);
                        break;
                case SIGVTALRM:
                        printf("Catch a signal -- VT \n");
                        //      signal(SIGVTALRM, sigroutine);
                        break;
        }
        return;
}



void sigalrm_fn(int sig)
{
        static int cnt = 9; 
        cnt--;
        if(cnt){
                printf(" SIGALARM:%d, cnt:%d!\n", sig,cnt);
                alarm(1);
                return ;
        }
        //_exit(0);
        //clear alarm
        alarm(0);
        return;
}



int main()
{



           itimerval value, ovalue, value2; //(1)
           sec = 5;
           printf("process id is %d\n", getpid());
           signal(SIGALRM, sigroutine);
           signal(SIGVTALRM, sigroutine);
           int start_fire_time = 3; 
           int interval_time = 1; 
        // timer first fire from t0=0+10, then intervally fire at 10+4
        value.it_value.tv_sec = start_fire_time;
        value.it_value.tv_usec = 0;
        value.it_interval.tv_sec = interval_time;
        value.it_interval.tv_usec = 0;
        setitimer(ITIMER_REAL, &value, &ovalue); //(2)


        value2.it_value.tv_sec = 0;
        value2.it_value.tv_usec = 500000;
        value2.it_interval.tv_sec = 0;
        value2.it_interval.tv_usec = 500000;
        setitimer(ITIMER_VIRTUAL, &value2, &ovalue);

        //signal(SIGALRM, sigalrm_fn);
        //alarm(3);

        for(;;){
;
        }
}

int run_cmd(char* cmd, char *res){
        FILE *pf = popen(cmd, "r");
        const int TO_READ_SZ = 1023;
        if ( 0 != fread(res,TO_READ_SZ, 1, pf)){
                printf( "- cannot run system cmd %s\n", cmd ); 
                return -1; 
        } ;
        pclose(pf);
        return 0;
}


// ////////////////////////////////////////////////////
// windows pipe _popen() 
int run_cmd(char* cmd, char *res) {
	FILE *pf = _popen(cmd, "r");
	const int TO_READ_SZ = 1024;
	if (0 != fread(res, TO_READ_SZ, 1, pf)) {
		printf("- cannot run system cmd %s\n", cmd);
		return -1;
	};
	_pclose(pf);
	return 0;
}

int _tmain(int argc, char** argv)
{
    ofstream of("x:\\txt1.txt", ios::out); 
    of << "ABC123" << endl ; 
    of.close(); 


    ifstream if_("x:\\txt1.txt", ios::in); 

    int cnt = 9; 
    int x = 0; 


    string sb = ""; 
    const int ENTER_KEY = 10;
    while( -1 != (x = if_.get()) && x != ENTER_KEY ){
        sb += x; 
    }

    if_.close(); 

    cout << "---"<< sb << "---"<<endl;    // need chomp 
    __P__; // system("pause");
    return 0;
} // end main()

// to_string_() write_buf_2_file()
//#include <thread>
//#include <chrono>
//#include <atomic>
#ifdef _MSC_VER
  #include <Windows.h>
#endif
#include <cstdarg>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>
//#include <opencv2/opencv.hpp>
using namespace std; 
#define OF_W (ios::out|ios::trunc)
template<typename T>
string to_string_(T n){
	ostringstream ss; 
	ss << n ;
	return ss.str();
}
void write_buf_2_file(const string & fn, unsigned char* buf , int rows, int cols){
	// #define OF_W (ios::out|ios::trunc)
	int i = 0; 
	int j = 0;
	string sb = ""; 
	for(i=0;i<rows;i++){
		for(j=0;j<cols;j++){
			//buf[i*cols+j] = (i+j)%255; 
			unsigned char t = buf[i*cols+j]; 
			sb += to_string_( (int)(t) );
			sb += " ";
		}
		sb += "\n"; 
	}
	ofstream of_(fn.c_str(), OF_W); 
	of_ << sb ; 
	of_.flush();
	of_.close(); 
} 
#define  JD_LOGE_9(STR) \
	static int cnt_9 = 0; \
if ( cnt_9++ == 0 ){ \
	LOGE("--- JD LOG_9 %s: function:%s, line:%d----",STR,  __FUNCTION__, __LINE__); \
} \
; 


//perl append 
open my $FP, ">>$FN";
close $FP;
// g++ -std=c++11 setenv.cpp  && time ./a.out
// setenv 
// perl -e 
#include <stdlib.h>
#include <stdio.h>

#ifdef _MSC_VER 
#define putenv _putenv
#endif

// #define PERL_INTERP_START  "perl -e \"  
// #define PERL_INTER_END \"  "

int main() {

                putenv((char*)(
                     "abc=abcvarEND2 "
                     ));


#ifdef _MSC_VER 
        system(
                " perl -e \" \
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \
                     print @ENV{abc}x2;                                 \
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \
                     \"  "
        );
#else 
        system(
                " perl -e \' \
                     $_______________________________; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     $_______________________________; \
                     \'  "
        );
#endif 

return 0; 

}

# !/bin/bash
export now=`date "+%Y%m%d_%H%M"`
#echo cur pid is $$ 

export out_file=cpu_perc_${now}.txt

export PID0_PID1=$( pgrep -f watchdog.py | perl -e ' map{chomp; my @t=`ps af |grep $_`; @t = grep m/\\_ \./,@t; $_=@t[0];@tt0=split; $_=@t[1]; @tt1=split; print @tt0[0], " ", @tt1[0]; }<>'  )
#echo ${PID0_PID1}


while true;do
        export  now=`date "+%Y%m%d_%H%M"`
        perl -e ' open $FP, ">>@ENV{out_file}";  $now=@ENV{now};   $_=@ENV{PID0_PID1}; @t=split; map{ @top_log=`top -b -p @t[$_] -n 1`;   $_= @top_log[-1]; @pid_cpu=split;$w=qq($now,@pid_cpu[11]=@pid_cpu[8],); print $w; print $FP $w;}(0..1);  print qq(\n); print $FP qq(\n); close $FP;   '
        sleep 5s
done




exit 0

// shell bash perl
#!bash 


perl -e '  
### perl start ###
        @a=(0..9); 
        print "@a" x 5;
### perl end ###
'  > txt.txt 

#!perl
use strict ;
### global var ###
my $roi_idx = 2; 
my $filter_num = 144.00;
##################
my @arr_content = (); 
die "- no argv, please run\n\tperl test.PL cpu_perc_3082_20170614.txt\n" if  @ARGV == 0; 
q( 
####### filename ######## 
"                        "
DATA :
20170614_2346,tmpdata=212.8,20170614_2346,sonogui=6.647,  
20170615_0210,tmpdata=19.6,20170615_0210,sonogui=6.634,
20170615_0210,tmpdata=199.6,20170615_0210,sonogui=6.634,
"                        "
##########################
); 

my $filename = @ARGV[0] ; 
@arr_content = `cat $filename| grep 2017`;
@arr_content = 	sort { &parse_roi_num($a) <=> &parse_roi_num($b) }   @arr_content ; 
@arr_content = &filter_ascend_arr_by_cond(\@arr_content, $filter_num);
my @arr_to_av = &get_out_roi_arr(\@arr_content); 
my $len = @arr_to_av; 
my $average_num = &aver(\@arr_to_av); 
print qq(\$average_num of \$len $len is $average_num \n); 




### sub list ### 
sub get_out_roi_arr(\@){
	my $addr = shift @_;
	my @arr_ret = (); 
	for my $e (@$addr) {
		push @arr_ret , &parse_roi_num($e);
	}
	return @arr_ret ; 
}
sub filter_ascend_arr_by_cond(\@ $){
	my $addr = shift @_; 
	my $filter_num = shift @_; 
	my $cnt = 0; 
	while(1){
		my $__ = @$addr[$cnt++] ; 
		last if &parse_roi_num($__) > $filter_num; 
	}
	my $len = @$addr;
	my @arr_content = @$addr[ $cnt..$len-1] ; 
	return @arr_content; 
}
sub parse_roi_num(){
	my $line = shift @_;
	my @t = split m/[\,\=]/, $line; 
	return @t[$roi_idx];
}
sub aver(\@){
	my $addr = shift @_;
	my $len = @$addr ; 
	my $sum =0; 
	for my $e (@$addr) {
		$sum += $e; 
	}
	return $sum/$len;
}


// read file to uchar buf , and show as img 
using namespace std;



#define OF_W (ios::out|ios::trunc)
#define IF_R (ios::in)




template<typename T>
string to_string_(T n){
    ostringstream ss; 
    ss << n ;
    return ss.str();
}
void write_buf_2_file(const string & fn, unsigned char* buf , int rows, int cols){


    // #define OF_W (ios::out|ios::trunc)

    int i = 0; 
    int j = 0;
    string sb = ""; 
    for(i=0;i<rows;i++){
        for(j=0;j<cols;j++){
            //buf[i*cols+j] = (i+j)%255; 
            unsigned char t = buf[i*cols+j]; 
            sb += to_string_( (int)(t) );
            sb += " ";
        }
        sb += "\n"; 
    }

    ofstream of_(fn, OF_W); 

    of_ << sb ; 
    of_.flush(); 

    of_.close(); 

}




int _tmain(int argc, char** argv)
{


    const int rows = 512; 
    const int cols = 590; 
    unsigned char buf[rows*cols] = {0}; 
    int  a = 0; 

    int cnt = 0; 

    double Time = (double)cvGetTickCount();

    ifstream if_( "x:\\512x590_imgdata.txt" , IF_R ); 
    // filecontent is: 512*590 : 121 55 22 0 9 
    //ifstream if_( "x:\\txt.txt" , IF_R ); 
    while( 1 ){
        if_ >> a ; 
        if (if_.eof()) break;
        buf[cnt++] = (uchar)a; 
        //printf( "%d \n", a); 
    }
    if_.close(); 


    Time = (double)cvGetTickCount() - Time;

    printf( "run time = %gms\n", Time /(cvGetTickFrequency()*1000) );

    cout<< to_string_(int(buf[ rows*cols-6 ])) ;  

    Mat id_m(rows, cols, CV_8UC1); 
    int cntt = 0; 
    for( int i=0;i<rows;i++){
        for( int j=0;j<cols;j++){
            auto &t = id_m.row(i).col(j).data[0];
            t = buf[cntt++];    
        }
    }


    imshow( "id_m", id_m); 

    imwrite( "x:\\id_m.bmp", id_m); 
    waitKey(0);

    __P__; // system("pause");
    return 0;
} // end main()






///////
// read txt to img and buf iplimage 

void read_file_2_iplimage_and_show(string& fn, int rows, int cols ){

    int rows_ = rows;
    int cols_ = cols;
    int i =0; 
    int j =0; 
    IplImage *id_m = cv_c( cvSize(cols_, rows_), 8, 1 );  // mem 0
    //int rows = id_m->height; 
    //int cols = id_m->width;
    int step = id_m->widthStep; 


    ifstream if_( fn.c_str(), IF_R ); 
    int x = 123 ;

    for( i=0;i<rows; i++){
        for( j=0;j<cols; j++){
            char &tt = id_m->imageData[i*step+j]; 
            if_ >> x ; 
            tt = x ; 
        }
    }

    show_iplimg( id_m ); 
    cvReleaseImage( &id_m ); 
}


int _tmain(int argc, char** argv)
{
    int rows = 600; 
    int cols = 510;
    read_file_2_iplimage_and_show(string("x:\\pBufsc.txt"), rows, cols ); 

    __P__; // system("pause");
    return 0;
} // end main()

// perl get_timestamp 
#!perl

print &get_timestamp(); 







### sub list ### 
### perl timestamp ### 

sub add_zero_if_lt_10($){
	my $num = shift @_; 
	if ($num >=10 ){
		return "$num" 
	}
	return "0$num"; 
}
sub get_timestamp(){

# perl get time, for second:
 #perl -e 'print $^T '
#1477400615
my $if_windows = "False"; 
$if_windows = "True" if @ENV{WINDIR}; 


    my $time_stamp = `date "+%Y%m%d_%H%M"` if $if_windows ne "True"; 

    if ( $if_windows eq "True"){
        my ($second, $minute, $hour, $date, $month, $yearOffset, $dayOfWeek, $dayOfYear, $daylightSavings) = localtime();
        # 17 16 20 24 7 116 3 236 1
        # 2016-08-24 20:16

        my $year = 1900 + $yearOffset;
        $month = $month + 1 ; 
        $month = &add_zero_if_lt_10($month); 
        $date = &add_zero_if_lt_10($date); 
        $hour = &add_zero_if_lt_10($hour); 
        $minute = &add_zero_if_lt_10($minute); 
        $time_stamp = "$year$month${date}_${hour}$minute"; 
    }

    chomp( $time_stamp ); 
    my $suffix_ = ""; 
    return "$suffix_".$time_stamp; 

}


EOF

/*
// move to another header file 
#define TO_STRING_  string to_string_(T tt) { \
stringstream ss; \
ss << tt; \
cout << ss.str(); \
return ss.str(); \
} \
;
#define S(x) to_string_((int)(x))
*/

template <typename T> TO_STRING_;    // to use to_string_(id_m)


#include <stdlib.h>
#include <stdio.h>

#ifdef _MSC_VER 
#define putenv _putenv
#endif



#define M_PI       3.14159265358979323846
int _tmain(int argc, char** argv)
{
 
    int n = 99; 
    char *env_n="env_n"; 
    string id_ss = string(env_n) + string("=") + S_( (int)&n ) ; 
    putenv( id_ss.c_str() ); 

  

    int *naddr =(int*) atoi(  getenv(env_n)  ); 
    int n_new = naddr[0]; 
    //cout << n_new << endl;  // => 99

    naddr[0] = 999; 
    cout << n << endl;  // => 999 


// mutex 
pthread_mutex_t mutex[DMA_NUM];
	    pthread_mutex_lock( &mutex[info.dma_no] );
	    ret = Do_sth(PiqHandle, &data);
	    pthread_mutex_unlock( &mutex[info.dma_no] );
		pthread_mutex_destroy(&mutex[i]);
    ifstream vfile("CFMdata/config.ini");
    
    if (vfile.is_open())


#c is file  exist 
    while(1){
// #include <io.h>
        if ( _access( "x:\\txt.txt", 0 ) != -1 ){
            cout << "- _access exist " << endl; 
        }

        ifstream if_("x:\\txt.txt", F_R); 

        if ( if_.is_open() ){
            cout << "- ifstream exist " << endl; 
        }
        if_.close();
        cout << "- sleep 2s\n"; 
        Sleep(2000);
    }
### matlab_ ### 

type txt.txt
pwd
[x, y] = size(id_m)

-fprintf
fp = fopen ( 'x:\\txt.txt', 'w'); 
fprintf(fp, '%d', a);
fprintf('%d\n',88)  %to stdout 
t=sprintf('%d', 88)
str2num(t)+1   % => 89
fclose(fp);
-
% this will be :   1.0000000e+00   0.0000000e+00   0.0000000e+00
save  a.txt  -ascii a   
can use read_file_2_float_buf_1d() to read 

-open close 
function fcout(id_m, idx)
% usage :
% fcout( id_m , 1111 ) 
% also can use "load xxxx_txt" or "loat xxx.txt" to load 
% ==> x:\txt_1111_8_x_8_txt
% === dlmwrite('x.txt', rand(9), ' ' )
[r,c] = size(id_m);
fn = sprintf( 'x:\\txt_%s_%0d_x_%0d_txt' , num2str(idx), r,c );
fp = fopen(fn, 'w');

for i=1:r
    for j=1:c
            fprintf( fp, '%d ', id_m(i,j) );
    end
    fprintf( fp, '\n' );
end 
disp(fn)
-

if 1 == 1 && 2 == 2
  disp(1)
end

if 1 ~= 2 


x(1:2,:)

- a m file with different function 
>> type t.m

function tt=t(a)
tt=t1(a)+t2(a);
end

function t1_=t1(a)
t1_=a;
end

function t2_=t2(a)
t2_=a;
end
-

strcat( 'abc', '4' )
-img 
lena=imread('x:\\lena.bmp');
lena(1:44,1:44) = 0; 
imshow(lena);

plot(xx,yy, 'b.');
-




// cv mat new usage 
Mat id_m = Mat( rows, cols, CV_8UC(1), pData, cols ); 

---dot_ ---
dot -V
dot -Tpng test.dot -o test.png & ecd test.png
http://blog.jobbole.com/94472/  demo
digraph "server"
 {
 graph["splines"="curved","overlap"="scalexy","rankdir"="LR"]
 node["fontsize"="8px","fontname"="arial","shape"="rect","margin"=0,"pad"=0,"style"="solid"]
 "1" -> "2" ;
 }
/* no direct */
graph abc{
a -- B;
B -- a[color=red];
}
digraph abc{
 "a b c" -> b;
 b -> c;
} 

graph minimal_nonplanar_graphs {
  size="9,19"

  URL="http://en.wikipedia.org/wiki/Kuratowski_theorem#Kuratowski_subgraphs"
  tooltip="click for \"Kuratowski theorem\""
  JD="JD"
  labelloc=t           
  label="Minimal nonplanar graphs (9 edges / 5 nodes)"
  node [style=filled]

  subgraph cluster_0 {
bgcolor="yellow";
    label="K_3,3"  color=lightblue  style=filled
    node [color=white]
    {A B C} -- {D E F}
  }

  subgraph cluster_1 {
    label=K_5  color=blue
    node [color=yellow  shape=box]
    1 -- {2 -- {3 -- {4 -- 5}}}
    } 
}

graph minimal_nonplanar_graphs {
  size = "8,8";
  subgraph sub_0{
    a [shape=box,fillcolor=green,/*style=dashed,*/style=filled];
    b;
    c;
    d;
    {a,b} -- {c,d};
  }
}
digraph sub_0{
  labelloc=t  
  label="this is a label"
  node [shape=record];  //rect
  edge [style=dashed];  //虚线
    a;
    b;
    c;
    d [shape=none, image="t.png" , label=""];
    a -> { b -> { c -> d[color=red] } } ;
  }

digraph abc{

  node [shape="record"];
  edge [style="dashed"];

  a [style="filled", color="black", fillcolor="chartreuse"];
  b;

    subgraph cluster_cd{
      label="c and d";
      bgcolor="mintcream";
      c;
      d;
    }

  a -> b;
  b -> d;
  c -> d [color="red"];
}
//table 
digraph abc {
//rankdir=TB;
node [shape=record,color="skyblue",];
// node [shape="plaintext"]; 
edge [];
a;
1;
0 [shape=doublecircle , style=filled];
A;
a [label="
{<a_>a|
b|
c}
"];
1 [label="1|<_2_>2|3|4"];
A [label="A|B|C"];
1:_2_ -> a:a_;
1 -> A;
  0 ->0 [label="fuck self",shape=diamond];  // shape = "Mrecord",   圆角矩形

}

-
  rankdir = "TB";  // LR 
  fontname = "Courier New"
  fontsize = 100; // big picture

  node [shape = doublecircle];
  
LR_0 LR_3 LR_4 LR_8; 
-
-time sequence-
digraph G {
size="10,10"
rankdir = "LR";
node [shape="point",width=0, height=0];
edge [ arrowhead=none];

{
rank = "same";
a[shape=plaintext]
a -> a0 -> a1 -> a2 -> a3 -> a4; 
}

{

rank = "same";
b[shape=plaintext]

b -> b0 -> b1 -> b2 -> b3 -> b4; 
}

edge[arrowhead=""];

a0->b0;
a1->b1;
b2->a2;
}
-


    //--- cv draw rotate rectangle 
#define IMG_WIN_HEIGHT 820
#define IMG_WIN_WIDTH 1130

#define LINE_P_NUM 10000

    const int rows =  IMG_WIN_HEIGHT;
    const int cols =  IMG_WIN_WIDTH;

    Mat id_m( rows, cols, 0); 
    clear_img( id_m );

    string id_s("");
    RotatedRect rRect=RotatedRect(Point2f(cols/2,rows/2),Size2f(22,400),-30);
    Point2f vertex[4];
    rRect.points(vertex);//提取旋转矩形的四个角点
    for(int i=0;i<4;i++)
    {
        id_s += to_string_(vertex[i].x) + " " + to_string_(vertex[i].y) + "\n";
        line(id_m,vertex[i],vertex[(i+1)%4],Scalar(255));//四个角点连成线，最终形成旋转的矩形。
    }

    fcout( id_s , 1111);
    show_mat(id_m);
// end cv draw 
-


#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

int main(){

const char *s= string("abc 12345 bcd").c_str();
int a =0;
sscanf(s, "abc %d", &a);
cout << a<< endl;

}



import tensorflow as tf
import numpy as np
import re
import random
import os
print "- import end"
lines_to_return = (range(0,9))
lines_to_return[1] = 9
lines_to_return[2] = 9
print lines_to_return
### classv.PL ### 
*********************
\home\tanglq\t\classv.PL
*********************
#!perl
use strict;
# 1.put all the source file to one single file, .e.g: all_content.txt
# 2.run : cat all_content.txt | grep '^class ' | sort -u > txt.txt , 
#   this will grasp out class out;
# 3.run :
#   perl test.PL TO_FILTER_0 TO_FILTER_1 > test.dot 
# 4.show the dot file as png 
#
# usage :
#   perl test.PL K I Q
#
# written by Jidor Tang at 2017-8-5

if (@ARGV == 1 && @ARGV[0] eq "_all_"){
 @ARGV = ( "K", "Q", "I", "D", "P", "V", "T", "S", "N", "C" ); 
}
if ( -e "allclass.txt"){}
else {
	die "- no file \"allclass.txt\"\n";
}
my @vars = `cat allclass.txt|sort -u`;

my @arr = @vars ; 

### pre process ###
chomp(@arr);
@arr = grep !m/google/, @arr;
@arr = grep !m/\:\:/, @arr; 
@arr = grep !m/\;$/, @arr; 
my @arr_inherit = (); 

map{
	chomp;
	s/\;//g;
	s/\{//g;
	s/\s+/ /g;

	my @t = split m/\s+/; 
	if (@t[2] eq ':' || @t == 2){
		push @arr_inherit , (join ' ',@t); 
	}
}@arr;
my @after_filter = ();
my %hash =();
for my $t (@ARGV) {
	my $to_filter_t = $t; 
    if ($to_filter_t !~ m/\w/){
	  next;
	}
	my @arr_inherit_0 = grep m/$to_filter_t/i, @arr_inherit; 
	push @after_filter, @arr_inherit_0; 
}
@arr_inherit = @after_filter; 
@arr_inherit = grep { ++$hash{$_} < 2 } @arr_inherit;

my @all_graph = ();
### generate the dot graph ###
map{
	chomp;
	s/class //g;
	my @t = split;
	my $i=0;
	for ( $i=0;$i<@t;$i++){
	 if (@t[$i] eq ':'){
	 last;
	 
	 }
	}
	my @element = ();
	@element = ( @t[($i+1)..(@t-1)]  , " -> ",  @t[0..$i-1] ) if @t > 2; 
	@element = ( @t[0..1] ) if @t <= 2; 
	if ( @element[0] =~ m/public/ ){
	  push @element, ""; 
	}
	elsif (@element[0] =~ m/virtual/ ){
      push @element , "[style=dashed]";
	}

	#push @element, ";\n";
	if (@element == 2){
		unshift @all_graph , \@element; 
	}
	else { 
        push @all_graph , \@element ; 
	}
}@arr_inherit; 

### display ###
my $dot_statement = '
digraph abc{
randir="TB";
node[shape=record];
__STAT__
}

'; 
my $dot_kernel = ""; 
for my $t (@all_graph){
	my @element = @$t ; 
	my $outstr = "@element";
	$outstr =~ s/public //g;
	$outstr =~ s/virtual //g;
	$dot_kernel .= $outstr.";\n"; 

}
$dot_statement =~ s/__STAT__/$dot_kernel/; 
print $dot_statement; 

# cat pad_v_fe_be_cpp_h.cpp | grep  '^class ' | sort -u  > txt.txt 
# cat vm_cpp_h.cpp | grep  '^class ' | sort -u  > txt.txt

EOF

    auto b_flag_save =  QFile::exists("savedscimg");
    /*
    auto range_int=[](unsigned int uiMaxRange)
    {
        const unsigned int ONE_MILLISEC              = 1; //1毫秒
        const unsigned int ONE_SEC                   = 1000  * ONE_MILLISEC;
        QTime time;
        time = QTime::currentTime();
        qsrand(time.msec() + time.second() * ONE_SEC);
        int i_rand_num = qrand() % uiMaxRange + 1; // 1 ~ uiMaxRange
        return i_rand_num;
    };
    range_int(10);
    */

free -m 
to see free memory in device

# read and write binary #

ofstream of_( "x:\\txt.bin" , std::ofstream::binary); 
int i = 0x22333344;  // 00000000: 4433 3322     D33"
cout << i<< endl; 
of_.write(reinterpret_cast<char*>(&i), sizeof(i) ); 
of_.close();

ifstream _if_( "x:\\txt.bin", std::ifstream::binary); 
int j=0; 
_if_.read (reinterpret_cast<char*>(&j), sizeof(j) ); 
cout << j<< endl;
_if_.close(); 

x  = pd.read_csv( "txt.txt",sep=" ", header=None)

printf("%I64u\n",i<<62);


df = pd.DataFrame(  [ [1,2,3], [2,2,4] ] )
print (df)                 
for k,v in enumerate(df[2]):
    print ("k,v " + str(k) + " " + str(v))
# "date","sc","sn","mn","ayep",     "sp",     "hi",   "lo",       "ep",  "vo",   "tm",     "tt",      "yep"
# "date","sc","sn","mn","实际昨收盘","今开盘价","最高价","最低价","今收盘价","成交量","成交金额","成交笔数","昨收盘价"

-datetime-
import datetime 
id_dt_0 = datetime.datetime(2012, 4, 24, 15, 6, 0, 10)
id_dt_1 = datetime.datetime(2012, 4, 4, 15, 6, 0, 0)
id_dt_2 =  datetime.datetime(2012, 5, 4, 15, 6, 0, 100)
print ( str(id_dt_2 - id_dt_1) )  # '30 days, 0:00:00.000100'
ldt = [ id_dt_0 , id_dt_2, id_dt_1 ]
ldt.sort()

for i in ldt:
    print (i)
import dateutil
help ( dateutil )

from dateutil.parser import parse
a = (parse( "2017-08-19 21:00")) # Sunday
print (a.weekday()+1)  #  6 

def see_c_f(class_, fun_="", openhelp=0):
    """
    need : import numpy
    see_c_f ( np, "mat",0) 
    """
    name = (str(class_).split(" "))[1]
    name = name.replace("'","") +"."
    #print (name)
    assert(type(fun_) == type("str"))
    if fun_ == "" :
        print (dir(class_))
        return 0
    list_fun = dir(class_)
    for e_fun in list_fun:
        #print(i)
        if openhelp == 0 and not str(e_fun).find(fun_):
            print ( "- "+ (name + str(e_fun)).strip() + ""  )
        if openhelp == 1 and str(e_fun) == (fun_):
            print ("====== "+ (name + str(e_fun)).strip() + " ======")
            eval_statement = (name + str(e_fun)).strip()
            eval( " print ( " + eval_statement + "." + "__doc__" + ")" ) 


// generate all src code 
#!perl 
use strict;
my $curdir = `pwd`;
#curdir can be change here
chomp($curdir);
my @arr = `( find $curdir -name '*.h' ; find $curdir -name '*.cpp' ) | grep -v /depends/win/ | sort -r >  txt.txt `; 

@arr = `cat txt.txt`; 

@arr = grep !m/moc_/, @arr; 
@arr = grep !m/ui_/, @arr; 


my $len = @arr; 

#print @arr[0]; 

#@arr=(@arr[0],@arr[1]);

my $windows_path = 'V:\svn\br-1.8\src';

my @arr_all = &print_all_files( \@arr ); 
my $str_all = join '', @arr_all; 

open my $FP, ">", "vista_src_all_cpp"; 
	print $FP $str_all;
close $FP; 
system( " dos2unix  vista_src_all_cpp " ); 

print "- please run:\n\tcp vista_src_all_cpp \$t/vista_src_all_br_1_8.cpp\n " ;

### sub list ###
sub print_all_files(\@){
	my @arr_all = (); 
	my $addr_ = @_[0]; 
	my @ARGV_ = @$addr_;
	use feature qw(say); 

	my $NEED_ONLY_WINDOWS_NAME = 1;

	map{
		chomp;
		if(-T "$_") {
			push @arr_all,  "\n*********************\n";

			if ( !$NEED_ONLY_WINDOWS_NAME ){
				push @arr_all, $_."\n" ;
			}

			if ( $NEED_ONLY_WINDOWS_NAME ){
				my $t = $_; 
				chomp ($t) ;
				if ( $t =~ m/br\-1\.8/ ){	
					#$t =~ s/\/home\/tanglq\/depot\/br.1.4\/01_code/E\:\\br-1.4\\01_code/; 
					$t =~ s/\/data\/tanglq\/svn\/br.1.8\//V\:\\svn\\br-1.8\\/;
#my $windows_path = 'V:\svn\br-1.8\src';
				}
				else {
				  $t =~ s/\/home\/tanglq\/depot\/svn\/01_code/D\:\\trunk\\01_code/; 
				}
				$t =~ s/\//\\/g;
				push @arr_all,  $t."\n";
			}

			push @arr_all, "*********************\n";
			push @arr_all,  `cat $_`;
		}


	}@ARGV_;

	push @arr_all,  "EOF\n";

return @arr_all; 
}

// save vector data

  string id_save_data = "";

  for ( auto &t : vec_ngs_simu){
      cout << t.pkg_header.packet_counter << endl; 

      uchar * p_begin =  (uchar*)&t;
      uchar * p_end =  (uchar*)&t + sizeof(t);
      string s_tmp = string(p_begin, p_end);

      id_save_data += s_tmp;

  }
   
   FILE *fp = fopen("Z:\\t.txt", "wb"); 
   fwrite(id_save_data.c_str(), 1 ,id_save_data.size(),fp);

   fclose(fp);



#if 1
      
   FILE *fp_r = fopen("Z:\\t.txt", "rb"); 
   for(int i=0;i<num;i++){
       stru_ngs_simu_data each_pkg; 
       fread( (void*)&each_pkg, 1 ,sizeof(each_pkg),fp_r);
       cout << each_pkg.pkg_header.packet_counter << endl;  
   }
   fclose(fp_r);
#endif




<<<<<<< HEAD

// arr to string 	
#include <stdio.h>
#include <cstdarg>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <iostream>
using namespace std; 

template<typename T>
string to_string_(T n){
	ostringstream ss; 
	ss << n ;
	return ss.str();

}

template <typename T>
string arr_to_string_1d(T *buf, int len){
	string outs = ""; 
	for( int i=0;i<len;i++){

		outs += to_string_(buf[i]) + " "; 

	}
	outs += "\n";


	return outs; 
}

template <typename T>
string arr_to_string_2d(T *buf, int rows, int cols){
	string outs = "";
	for ( int i=0;i<rows;i++){
		for( int j=0;j<cols;j++){
			outs += to_string_(buf[i*cols+j]) + " "; 
		}
		outs += "\n";
	}

	return outs; 
}

int main(){



	float arr[] ={88.889, 999}; 

cout << arr_to_string_1d( arr , 2 ); 

float arr_2d[2 * 4]={
1 , 2 ,3,4,
2 , 2 ,4,4,
};

cout << arr_to_string_2d(arr_2d, 2, 4); 
return 0;
}

=======

git commit issue:
git commit -m'all'  -a 
git remote set-url origin https://github.com/tlqtangok/s.git

pandas plot scatter
# see_c_f(df,"ix")
df = df.reset_index()
df = df.head(4)
df = df.reset_index()
plt.xticks(np.linspace(0,5,6),np.array(df.dt),rotation=-30)
plt.yticks(np.linspace(0,1000000,9),np.linspace(0,1000000,9),rotation=30)
plt.plot(df.vo)
plt.show()
# plt.xticks?

# -----> 1
  |
  |
  0
df = df.drop(['tm','dt'],1) # del cols  

x = np.arange(9)
df = pd.DataFrame({
    'f0': x,
    'f1':x*3 -7,
    'f2':7/(x*1.0+1.0)
    
})

df.plot.bar(y=["f2","f0","f1"])
plt.show()
df.plot.scatter(x=["f0","f0"], y=["f2","f1"])
plt.show()

df["idx"] = np.arange(len(df))
df.plot.bar( x=["idx"],y=["f1","f2","f0"])
plt.show()

df["idx"] = np.arange(len(df))
df.plot.bar( y=["f1","f2","f0"])
plt.show()

df = pd.DataFrame(
[
 [1 ,2 ,3],
 [11 ,22 ,33]
],
 index = [0,1],
 columns = ["f0","f1","f2"]
)

df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df

df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df_ = pd.DataFrame(
np.mat("1 2 33; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)

pd.concat([df,df_])
df = pd.DataFrame(np.eye(3)).astype(np.int).rename(columns={0:"f0",1:"f1",2:"f2"})
df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df_ = pd.DataFrame(
np.mat("1 2 33; \
       4 5 6"),
 columns = ["f0_","f1_","f2_"]
)

pd.concat([df,df_], axis = 1)

# => 0 2
     1 4
df = df.melt()  

df = df.rename(columns={'f0':'f00'})
df

df = df.query('f1 == 2')
df

df = df.sort_index(ascending=0)
df = df.reset_index()
df.drop(["index"],1)
df.drop([0] )  #drop one line 

df.filter(regex='f[1-2]')
df[["f0","f1"]]
df.loc[:1,"f0":"f2"]  # included !!! , different with np
df.loc[ df["f0"]>1 , :]  # can only use "f0"
df.loc[ df["f0"]>1 , ["f1","f0"]]
df.iloc[:1,0:2]  #not include, can not use "f0" , only number

df.drop_duplicates() # unique
df.sample(frac=0.5)  # randomly get half of item 
df.sample(n=2)
df.nlargest(2,'f0')
df.f0.value_counts()  # get a hash that indicate the number of each element 

df.nunique() 	# return the unique num of each field 

- qcut -
print df
ds = np.arange(8)
np.random.shuffle(ds)
print ds
df = pd.qcut(ds, 5, labels=["C-","C+","B", "A-", "A+"])
print df 
list(df) 

df.max(axis=1)
df.clip(lower=2, upper=3,axis=0 ) #trim to board is not in the range 

t = df.groupby(by="f0")
df.groupby("f0").size()

for i in t:
    print i[0]
    print i[1].values

-shift
df.shift(1,axis=1)

-merge 
df0 =  pd.DataFrame (np.mat( "1 2 ; 3 4"), columns=["f0","f1"])
df1 =  pd.DataFrame (np.mat( "1 2 ; 33 44"), columns=["f0","f1"])
pd.merge( df0,df1, how='outer')

-applymap
f = lambda x: str(x) * 3
df["f0_"] = df.applymap(f).f0
df["f0_"] = pd.DataFrame(df.f0).applymap(f)
pd.DataFrame(df.dt).applymap(lambda x : parse(x).weekday()+1)
df

df = pd.DataFrame({
    "dt" : ["20120901","20130909" ],
    "val":[1 ,2],
    "vo":[4,6]
})
df.pivot(index="dt", columns="val", values="vo")

val 		1 	2
dt 		
20120901 	4.0 	NaN
20130909 	NaN 	6.0

-numpy resize
id_m = np.mat("1 3").astype(int)
id_m.resize(3,3)
id_m

id_m = np.mat("1 2 4")
np.r_[id_m,id_m]
np.r_[3, [0]*5, -1:3:0.8]  # row array 
np.c_[id_m,id_m]

from numpy import poly1d
p = poly1d([2,3,4])
p(0) = 2x^2 + 3x^3 + 4

np.linalg.solve( np.mat("2 1;1 -1"), np.mat("2;1") )

plt.subplot(221)
plt.scatter( id_l, id_s)
plt.subplot(222)
plt.scatter( id_l, id_s)
plt.subplot(223)
plt.scatter( id_l, id_s)
plt.subplot(224)
plt.scatter( id_l, id_s)
plt.savefig("myf.jpg")
plt.show()

b = np.mat([1/4.0, 3/4.0][::-1]).T  # reverse list 

-cal the split of coorx0
x0 =  0
x1 = 10
a = np.mat( [x0,x1]) 
# a => lambda 
lambda_ = 1/10.0
b = np.mat([lambda_, 1-lambda_][::-1]).T
(a * b)[0,0]
-
from scipy import linalg , sparse
a = np.mat("1 0   ;0 9")
print linalg.sqrtm(a)
-
a = np.mat("1 3")
b = a
print (a * b.T)[0,0] == np.tensordot(a,b)
-
a = np.mat("3 -1 ;-1 3")
a = linalg.funm(a, lambda x: x*10)
a
-

// str serial bin file

//  xxd -i -c 244 one_frame_ngs_simu.dat
// str serial bin file 
template <typename T>
string serial_2_str( T&  pt)
{
	string id_s = ""; 
	char *c_pt = (char*)&pt; 
	id_s += string(c_pt, c_pt + sizeof(T)); 
	return id_s ; 
}

void str_2_bin_file(string fn, const string& str_to_serial)
{
	ofstream of_( fn.c_str(), ios::binary); 
	of_ << str_to_serial;  // never have "<< endl";
	of_.close();
}

string bin_file_2_str(string fn){
	ifstream if_(fn.c_str(), ios::binary); 
	
	string id_s = "";

	char c = 'E'; 
	

	while(!if_.eof()){
		if_.read(&c,1); 
		id_s.push_back((uchar)c);
	}

	//id_s.get_allocator.capacity(99);

	if_.close();
	// cout << id_s.size() << endl;   // if 4 + 4, then it is 8
	// const char* mydata = id_s.data(); 
	// cout << *(uint32_t*)mydata;
	// cout << (uchar)&str[3]
	return string(id_s.begin(),id_s.end()-1); 
}







// int main(
int _tmain(int argc, char** argv)
{

#if 1

	
	uint32_t a = 999; 
	uint32_t b = 9999; 


	string id_str = serial_2_str(a) + serial_2_str(b); 
	str_2_bin_file( string("d:/j/txt_txt"),id_str ); 

	string str =  bin_file_2_str( string("c:/j/txt_txt")); 
	cout << *(uint32_t*)(string(str.begin()+ 4 , str.begin()+ 8).data()) << endl;   // 9999
#endif




#if 1

	string fn = "D:\\j\\txt_txt";
	system((string(" del ") + fn ).c_str());

	uint64_t a= 99; 
	float f  = 88.88; 

	auto tt =  serial_2_str(a) + serial_2_str(f); 
	cout << tt << endl; 
	str_2_bin_file( fn, tt); 
	system((string(" xxd -i ") + fn ).c_str());

	cout << bin_file_2_str(fn)  << endl; 
	string p = bin_file_2_str(fn);
	cout << *(float*)(&p[0] + sizeof(uint64_t))  << endl; 



	struct AA{
		uint64_t a;
		float f  ;

	};

	auto p_id_a = (AA*)(&p[0]);
	cout << p_id_a->a  << endl; 
	cout << p_id_a->f << endl; 


#endif 


printf("0x%02x", (uchar)c); 


// vector usage 
#if 1

	vector<int> vec_c; 
	vec_c.resize(10+1); 
	vec_c[10]= 99; 

	for (auto i : vec_c){
	  cout << i << endl; 
	}


	auto p_int = vec_c.data();

	cout << p_int[10] << endl; 

	cout << vec_c.size() << endl; 

	vec_c.clear();
#endif

### get all perl src code ###	
my @arr = `( find $curdir -name '*.PL';find $curdir -name '*.pl'; find $curdir -name '*.t' ; find $curdir -name '*.pm' ) | grep -v /depends/win/ | sort -r >  txt.txt `;

// get col = ? , get cols value arr_col
 export arr_col="0 1"  && perl -pe '@arr_col=split / /,@ENV{arr_col}; @t = split; @ans=(); push @ans , @t[$_] for @arr_col; $_= "@ans". "\n";  '  txt.txt 


*********************
/home/tanglq/perl_p/ff.PL
*********************
#!perl
use strict;
use Data::Dumper; 
use feature qw(say);

=pod
fetch field from txt files

*** txt.txt ***
1 2 3
4 5 6
7 8 9
-----

run :
	perl ff.PL txt.txt 1 -1
=>
1 3
4 6
7 9
-----

=cut
die "- need 2 args, perl this_file.PL filename.txt \"arr_cols\"\n" if @ARGV < 2; 

my $fn = @ARGV[0];
my @fc = `cat $fn`; 

@ENV{arr_cols}=join " ", @ARGV[1..@ARGV-1]; 

my @arr_col=split / /,@ENV{arr_cols};
@arr_col = grep m/\w/,@arr_col;

my @ans_all = (); 
my @t = (); 
for (@fc) {
	chomp;
	my @arr_fc_each = split; 

	my @ans_each=(); 
	push @ans_each , @arr_fc_each[$_] for @arr_col;
	$_= "@ans_each";    

	#say  ; 

	push @ans_all, $_; 
}

say join "\n", @ans_all; 
#say ; 


#export arr_col="0 1"  && perl -pe '@arr_col=split / /,@ENV{arr_col}; @t = split; @ans=(); push @ans , @t[$_] for @arr_col; $_= "@ans". "\n";  '  txt.txt 






EOF

#perl and 
say if m/a/ and !m/A/; 

say if m/--c/ ;
use Cwd;
use File::Path;
use File::Find;

find({
		no_chdir=>1,
		wanted => sub{
			          say  ;
		             }
	},'.');

find({
		no_chdir=>1,
		wanted => sub{
			          say  ;
		             }
	},'/home/tanglq/t/tlq/');

my $cwd = cwd; 
print $cwd ; 

#!perl
# chinese enable #
use strict;
use File::Spec::Functions;
use feature qw(say);
use Cwd;
use File::Path;
use File::Find;



### global var ###
my $fn_output = "txt.txt";
##################



chdir(@ENV{vm}); 
my $cwd = cwd; 


my @fc_all = (); 
my @fn_all = (); 

@ENV{WINDIR} or die "- must Windows\n"; 
# find $curdir -name '*.h' ; find $curdir -name '*.cpp' ) | grep -v /depends/win/ | sort -r >  txt.txt `; 

find({
		no_chdir=>1,
		
		wanted => sub
		{
		  if ( /\.h$/ || /\.cpp$/   )
		  {
		 	  push @fn_all, $_ if !m|.depends.win.| and !m/ / and !m/bak\./ and !m/bak_script/; 
		  }
		}
		 
	},$cwd);

@fn_all = reverse sort @fn_all; 


for (@fn_all)
{
  push @fc_all, &get_fn_fc($_);
}

open my $FP, ">", $fn_output; 	
 print $FP @fc_all;
close $FP; 



sub get_fn_fc($fn)
{
  my $fn = shift; 
  $fn =~ s|\/|\\|g;
  my $id_s = "";
  $id_s .= "\n****************************\n"; 
  $id_s .= $fn; 
  $id_s .= "\n****************************\n"; 
  my @fc = `type $fn`; 
  $id_s .= "@fc"; 
  return $id_s;
}



# perl count 
$_ = qq(abcaba0); 
$_ = (tr/0/0/); 
say ;  # => 1


// gdb 
dump mem test.bin buf buf+100


# perl version 
print $] ;  # => 5.024001

*********************
/home/tanglq/t/jd_estimate_time_usage.txt
*********************
#include <time.h>
#include "opencv2/opencv.hpp"
#ifdef _MSC_VER 
#include "Windows.h"
#define putenv _putenv
#endif
//#define JD_ printf("- JD_ %s: %s: %d\n", __FILE__, __FUNCTION__, __LINE__) 
#define JD_ ((void)0) 
#define JD_SHOW_DIFF(R0) JD_;_JD_SHOW_DIFF(R0)


double JD_RT(char *tag)
{
	double Time = (double)cvGetTickCount();
	double ret_d =  Time / (cvGetTickFrequency() * 1000 ) ;
	printf("- JD time %s %gms\n",tag, ret_d); 
	return ret_d;
}

double JD_TIME_R0()
{
	double Time = (double)cvGetTickCount();
	return Time; 
}

void _JD_SHOW_DIFF(double R0)
{
	double jd_diff = (double)cvGetTickCount() - R0; 
	printf( "%.2f ms\n", jd_diff /(cvGetTickFrequency()*1000) );
}

#define FILE_STUB "jd_test"
static int flag_file_exist = 0; 			




// int main(

int _tmain(int argc, char** argv)
{


#if 1

	system("lsh");

	
	while(1)
	{


		if(0 != _access(FILE_STUB, 0)){
			flag_file_exist = 0;  // this process only take less than 1ms
		}
		else {
			flag_file_exist = 1; 
		}



		if ( flag_file_exist )
		{
			JD_RT("t0_scthread"); 
			double r0_scthread =   JD_TIME_R0();

			Sleep(2000);
			// do something 
			JD_SHOW_DIFF(r0_scthread);
		}


		Sleep(1000);
	}
#endif



EOF

# xxd 
xxd -ps , then use perl pack("H*", $output)
unpack("A*", $bin);

*********************
/home/tanglq/perl_p/num_arr_format_to_dec.PL
*********************
# perl any num format to dec 
#!perl
use feature qw(say);


my $fn = "";

$fn = @ARGV[0] if @ARGV;
die "- perl test.PL fn.txt\n" if ! -e $fn; 

my @fc = `cat $fn`; 


for my $e_l (@fc)
{
	say &p_e_l($e_l);
}



sub p_e_l($)
{
	my $e_l = shift; 
	my $ret_str = "";
	my @arr_e = split m/ +/, $e_l;
	@arr_e = grep !/^\s/, @arr_e;
	for (@arr_e)
	{
		my $t = 0; 
		if ( m/^[\-0-9]/ || m/^0x/ )
		#if ( m/^0x/ )
		{
			eval qq(\$t = $_;); 
			#my $str = sprintf "0x%0x ", $t;
			my $str = sprintf "%3d ", int( $t + 0.5);
			$ret_str .= $str;
		}
		else 
		{
			die "- error, num $_\n"; 
		}

	}
	return $ret_str; 
}

# cout << read_file_2_mat(string("x:/txt.txt"), rows, cols);
# [17, 34, 3, 85;
#   68, 17, 2, 5]

# usage
#   perl   $perl_p/hex_to_dec.PL txt.txt
#   txt can be "0x9 10 1e+10"


EOF

### numpy plot_xy ### 
import tensorflow as tf
import numpy as np
import re
import random
import os
import matplotlib.pyplot as plt
import pandas as pd
from scipy import linalg , sparse


#from __future__ import print_function

# "date","sc","sn","mn","ayep",     "sp",     "hi",   "lo",       "ep",  "vo",   "tm",     "tt",      "yep"
# "date","sc","sn","mn","实际昨收盘","今开盘价","最高价","最低价","今收盘价","成交量","成交金额","成交笔数","昨收盘价"

def read_file_to_arr( id_filename): 
    file = open(id_filename);
    lines = file.readlines();
    file.close(); 
    return lines



def load(fn):
    fc = open(fn).readlines()
    fc = [e for e in fc if len(e.strip())]
    id_str = ""
    for i in fc[:-1]:
        id_str = id_str + i.strip() + ";"
        
    id_str = id_str + i.strip()
    
    id_m = np.mat(id_str)
    return id_m

def plot_xy(id_m):
    plt.scatter( list(id_m[:,0]), list(id_m[:,1]),s=0.5)
    plt.show()
    
def see_c_f(class_, fun_="", openhelp=0):
    """
    need : import numpy
    see_c_f ( np, "mat",0) 
    """
    name = (str(class_).split(" "))[1]
    name = name.replace("'","") +"."
    #print (name)
    assert(type(fun_) == type("str"))
    if fun_ == "" :
        print (dir(class_))
        return 0
    list_fun = dir(class_)
    for e_fun in list_fun:
        #print(i)
        if openhelp == 0 and not str(e_fun).find(fun_):
            print ( "- "+ (name + str(e_fun)).strip() + ""  )
        if openhelp == 1 and str(e_fun) == (fun_):
            print ("====== "+ (name + str(e_fun)).strip() + " ======")
            eval_statement = (name + str(e_fun)).strip()
            eval( "print( " + eval_statement + "." + "__doc__" + ")" ) 

        
id_m = load("txt1.txt")
plot_xy(id_m)


#if _draw_convex_picture
	float R ; 
	float theta; 

	int MAX = 100; 

	float R_all = 22.0; 
	float start_a = -120; 
	float end_a = -20; 


	float d_a = (end_a-start_a) * M_PI / 180 / MAX * 1.0f ; 

	float d_r = R_all / MAX * 1.0f; 

	string id_s = ""; 
	
	for (int i=0; i< MAX; i++)
	{
		R = 0 + i * d_r; 
		for (int j=0; j<MAX; j++)
		{
			float b = d_a * j + start_a * M_PI / 180.0f ; 

			if ( R > R_all / 4.0f)
			{
				id_s +=  to_string_( cosf(b) * R )+  " "  +  to_string_(sinf(b)*R) + "\n" ;
			}

		}


	}

	fcout(id_s, 1111); 
#endif 

# python grep 
arr = [ e for e in list_i if m(e,"a") ]

# rm some file with '-p'
perl -e ' unlink(q(-p));'

*********************
split_perl_show_file.PL
*********************
#!perl
use feature qw(say);
use File::Basename qw(dirname);

my @arr = `cat txt.txt`;

my $i; 

my @ans = ();
for ($i=0; $i< @arr-3; $i++)
{
	if ( @arr[$i+0] =~ m/^\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ 
		&& 
		@arr[$i+2] =~ m/^\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ 
		&& 
		@arr[$i+1] !~ /^\s/)
	{
		
		#say $i , " " , @arr[$i+1] ; 
		push @ans, $i+1; 

	}

}



for($i=@arr - 1; $i>0; $i--)
{
	if (@arr[$i] =~  /^EOF.?$/)
	{
		last;
	}
}

push @ans, $i+1; 


my $len_ans = @ans; 

#my $idx = $len_ans -1 -1 - 0; 

for(my $j=0; $j<@ans-1; $j++)
{
	my $idx = $j; 
	my $fn_idx = @ans[$idx];
	my $fn = @arr[$fn_idx]; 
	chomp($fn);
	my $dirname_fn = dirname($fn);
	`mkdir -p $dirname_fn`;
	my @fc =  @arr[@ans[$idx]+2..@ans[$idx+1]-2] ; 
	open my $FP, ">", $fn or die; 
	print $FP @fc;
	close $FP; 
}

EOF

-

	// #include <stack>
	stack<int> id_stk; 

	int  arr[100];
	int cnt = 0;
	for (auto i : arr)
	{
		id_stk.push(cnt++);
	}

	int t = 0;
	id_stk.pop();
	t = id_stk.top();
	cout << t << endl; 


// read sam files  2018-01-24 in bgi
// t0.cpp : 定义控制台应用程序的入口点。
// g++ -std=c++11 test.cpp  -l pthread


//#include "stdafx.h"


#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <stdint.h>  // uint64_t
#include <assert.h>

#include <vector>
#include <sstream>
#include <map>
#include <algorithm>    // std::sort
#include <utility>

#include <stack>

#ifdef _WIN32
        #include "winpthreads.h"
#else
        #include <pthread.h>
        #include <pthread.h>
        #include <unistd.h>
        #include <sys/wait.h>
        #include <sys/types.h>
#endif



using namespace std;


#ifdef _MSC_VER
string fn = "E:/jd/t/test.sam";  // filename of sam
#else
//string fn = "./test.sam";
string fn = "./test_1kw.sam";
#endif


//#define __P__  system("date /t")
#define __P__  system("pause");return 0;

const char* CONST_STR_PG = "@PG\t";
const char* CONST_STR_PG_NO_TAB = "@PG";
const char* CONST_STR_SQ = "@SQ\t";
const char* CONST_STR_SQ_NO_TAB = "@SQ";
const char* CONST_INVALID_FLAG = "4";
const char* CONST_INVALID_XT_VALUE = "XT:A:R";
const uint64_t CONST_LEN_OF_READ = 35;
auto F_R = (ios::in);
const int MAX_CHAR = 128 * 4;


/////////////////////////////////////////////////////////////////////////////////
/*
const char* CONST_STR_PG = "@PG\t";
const char* CONST_STR_SQ = "@SQ\t";
const char* CONST_INVALID_FLAG = "4";
const char* CONST_INVALID_XT_VALUE = "XT:A:R";
const uint64_t CONST_LEN_OF_READ = 35;
const int MAX_CHAR = 128 * 4;
*/



void Stop(int signo)
{
        printf("oops! stop!!!\n");
        _exit(0);
}

void * f_sort(void * p_vect_)
{
        auto p_vect = (vector<uint64_t>*) p_vect_;
        std::sort((*p_vect).begin(), (*p_vect).end());
}

void throw_map_vect_2_threads_and_run(map<string, vector<uint64_t> >& map_chr_visit_pos)
{
        signal(SIGINT, Stop);

                pthread_t arr_t_sort[200];
                int cnt = 0;

                for( auto& e_chr_name: map_chr_visit_pos)
                {
                    //auto chr_name =  e_chr_name.first ;
                        auto& e_vect = e_chr_name.second;
                        if(e_vect.size() > 500)
                        {
                                auto res = pthread_create(&arr_t_sort[cnt], NULL, f_sort, &e_vect);
                                cnt++;
                        }
                        else
                        {
                                //std::sort(e_vect.begin(), e_vect.end());
                                f_sort(&e_vect);
                        }
                }


                for(auto i=0;i<cnt;i++)
                {
                        auto res = pthread_join(arr_t_sort[i], NULL);
                }
}


class CSamParser
{
public:
        CSamParser(const string &fn_sam);
        ~CSamParser();
        void display(int disp_level);
        void save_map_to_file(const string& fn_chr_len, const string& fn_chr_visit_pos);
        int get_visit_deepth(const string& chr_name, uint64_t detect_loc);


private:
        string fn;
        map<string, uint64_t> map_chr_len;
        map<string, vector<uint64_t> > map_chr_visit_pos;

        vector<string> split_str_2_vec(string &str, const char delimiter);

        string e_line;  //tmp line from file handler if_
        void read_sam_file_2_two_maps();

        void display_map_chr_len();
        void display_map_chr_visit_pos();

        string fcout(const string& fn, const string& id_s);
        CSamParser(); // invalid this default contructor
        template<typename T> string to_string_(T f)
        {
                ostringstream ss;
                ss << f;
                return ss.str();
        };
};
////////////////////
CSamParser::CSamParser()
{
}
void CSamParser::display(int disp_level)
{
        switch (disp_level)
        {
        case 0:
        {
                display_map_chr_len();
                break;
        }
        case 1:
        {
                display_map_chr_visit_pos();
                break;
        }
        default:
        {
                display_map_chr_len();
                cout << endl << "------------------------" << endl;
                display_map_chr_visit_pos();
                break;
        }

        }

}

void CSamParser::save_map_to_file(const string & fn_chr_len, const string & fn_chr_visit_pos)
{
        string id_s_map_chr_len = "";
        for (auto e_map_chr_len : map_chr_len)
        {
                id_s_map_chr_len += e_map_chr_len.first + " => " + to_string_(e_map_chr_len.second) + "\n";
        }
        fcout(fn_chr_len, id_s_map_chr_len);

        string id_map_chr_visit_pos = "";
        for (auto i : map_chr_visit_pos)
        {
                id_map_chr_visit_pos += i.first + "\n";
                for (auto j : i.second)
                {
                        id_map_chr_visit_pos += to_string_(j) + ",";
                }
                id_map_chr_visit_pos += "\n";
        }
        fcout(fn_chr_visit_pos, id_map_chr_visit_pos);
}

int CSamParser::get_visit_deepth(const string & chr_name, uint64_t detect_loc)
{
        int deepth_ret = 0;
        uint64_t chr_len = map_chr_len[chr_name];
        assert(chr_len >= detect_loc);
        assert(detect_loc >= 0);

        auto arr_visit_loc = map_chr_visit_pos[chr_name];
        auto len_arr_visit = arr_visit_loc.size();
        uint64_t detect_start = arr_visit_loc[0];
        uint64_t detect_end = arr_visit_loc[len_arr_visit - 1] + CONST_LEN_OF_READ;

        if (detect_end > chr_len)
        {
                detect_end = chr_len;
        }

        if (detect_loc < detect_start || detect_loc > detect_end)
        {
                return deepth_ret;
        }

        else {
                for (auto e_loc_start : arr_visit_loc)
                {
                        if (e_loc_start > detect_loc)
                        {
                                break;
                        }

                        auto e_loc_end = e_loc_start + CONST_LEN_OF_READ;
                        if (e_loc_end > chr_len)
                        {
                                e_loc_end = chr_len;
                        }

                        if (e_loc_start <= detect_loc && detect_loc <= e_loc_end)
                        {
                                deepth_ret++;
                        }
                }
        }

        cout << chr_name << " in loc " << detect_loc << " has visit deepth " << deepth_ret << endl;
        return deepth_ret;
}



CSamParser::CSamParser(const string & fn_sam)
{
        fn = fn_sam;
        read_sam_file_2_two_maps();
        //gen_map_chr_len();
        //gen_map_chr_visit_pos();
}

CSamParser::~CSamParser()
{
}

vector<string> CSamParser::split_str_2_vec(string & str, const char delimiter)
{
        std::vector<std::string>   vec_ret;
        std::stringstream  data(str);

        std::string line;
        while (std::getline(data, line, delimiter))     // assume
        {
                // Note: if multiple delimitor in the source string,
                //           you may see many empty item in vector
                vec_ret.push_back(line);
        }
        return vec_ret;
}


void CSamParser::display_map_chr_len()
{
        for (auto e_chr_len : map_chr_len)
        {
                cout << e_chr_len.first << " => " << e_chr_len.second << endl;
        }
}

void CSamParser::display_map_chr_visit_pos()
{
        for (auto i : map_chr_visit_pos)
        {
                cout << i.first << endl;
                for (auto j : i.second)
                {
                        cout << j << ", ";
                }
                cout << endl << endl;
        }
}

void CSamParser::read_sam_file_2_two_maps()
{
        auto F_R = (ios::in);
        ifstream if_(fn.c_str(), F_R);
        assert(if_.is_open());

        bool flag_meet_pg = false;
        while (!if_.eof())
        {
                //if_.getline(line_content, MAX_CHAR);  // don't need read too long
                std::getline(if_, e_line, '\n');
                if (e_line.size() <= 1)continue;
                auto arr_fields = split_str_2_vec(e_line, '\t');

                // classify to chr len and visit loc

                if (arr_fields[0] == CONST_STR_PG_NO_TAB)
                {
                        flag_meet_pg = true;
                        continue;
                }
                if (false == flag_meet_pg && arr_fields[0] == CONST_STR_SQ_NO_TAB)
                {
                        map_chr_len[arr_fields[1].substr(3)] = (uint64_t)atoi(arr_fields[2].substr(3).c_str());
                }
                else
                {
                        if (!(CONST_INVALID_FLAG == arr_fields[1] || CONST_INVALID_XT_VALUE == arr_fields[11]))
                        {
                                map_chr_visit_pos[arr_fields[2]].push_back(atoi(arr_fields[3].c_str()));
                        }
                }
        }
        if_.close();
#if 1
        throw_map_vect_2_threads_and_run(map_chr_visit_pos);
#endif

#if 0
        for (auto &e_map : map_chr_visit_pos)
        {
                auto& vec_t = e_map.second;             // the "&" is very important here !!!
                std::sort(vec_t.begin(), vec_t.end());
        }
#endif

}

string CSamParser::fcout(const string & fn, const string & id_s)
{
        const auto F_W = (ios::out | ios::trunc);
        ofstream if_(fn.c_str(), F_W);
        if (!if_.is_open()) {
                cout << "- make sure the file path is accessible!" << endl;
        }
        assert(if_.is_open());

        if_ << id_s;
        if_.close();
        //cout << fn << endl;
        return fn;
}


///////////////// jd end class ///////////////

int main() // jd add class
{

        ////////////////////////////////////////
        CSamParser sam_parser(fn);


        //sam_parser.display(3);

#if 1
#ifdef _MSC_VER
        sam_parser.save_map_to_file("E:/jd/t/map_chr_len.txt", "E:/jd/t/map_chr_visit_pos.txt");
#else
        sam_parser.save_map_to_file("./map_chr_len.txt", "./map_chr_visit_pos.txt");
#endif
#endif

        /*
        chr9
        4243687, 14418024, 18894111, 34036842, 34902334, 81513453, 103028956, 113602295, 123115616, 140680084,
        chrX
        21984874, 24996837, 34800528, 35347355, 44948944, 64326215, 76501054, 99810429, 111356763, 125844711, 131145026, 131145026, 132320814,
        */

        //sam_parser.get_visit_deepth("chrX", 131145026 + 4);   // expect 2
        sam_parser.get_visit_deepth("chr15", 20009098 + 1);  // expect 1


        //__P__;
        return 0;
}

# perl reference ref 
#!perl 
use feature qw(say);


my @arr=(
	6666, 4444,
	1,2,3,4); 
my %hash = @arr;  
my $addr_arr = \@arr; 
my $addr_hash = \%hash; 
print $addr_arr->[0] , "\n" ; 

say $addr_hash->{6666} ; 

// c++ getopt usage 
#include <iostream>
#include <unistd.h>
#include <cstdlib>

using namespace std; 

int main( int argc, char* argv[] )
{
	const char* nvalue = "World" ; 
	int tvalue = 1 ;

	int c ;
	while( ( c = getopt (argc, argv, ":n:t:") ) != -1 ) 
	{
		switch(c)
		{
			case 'n':
				if(optarg) nvalue = optarg;
				cout << (char)c << " => " << nvalue <<endl; 
				break;
			case 't':
				if(optarg) tvalue = std::atoi(optarg) ;
				cout << (char)c << " => " << tvalue <<endl; 
				break;
		}
	}

	for( int i = 0 ; i < tvalue; ++i )
		std::cout << '[' << i+1 << "] Hello " << nvalue << "!\n" ;
	std::cout << '\n' ;   
}

/*
g++ test.cpp  && ./a.out -n nv -t 5 
n => nv
t => 5
[1] Hello nv!
[2] Hello nv!
[3] Hello nv!
[4] Hello nv!
[5] Hello nv!
*/


// c++ namespace 
namespace samtools 
{
	vector<string> split_str_2_vec(const string & str);
	vector<sam_record> read_sam_file_2_vec_sam_record(const string & fn);
};


vector<string> samtools::split_str_2_vec(const string & str)
{
	std::vector<std::string>   vec_ret;
	std::stringstream  data(str);

	std::string line;
	while (std::getline(data, line, '\t'))	// assume 
	{
		// Note: if multiple delimitor in the source string, 
		//	     you may see many empty item in vector
		vec_ret.push_back(line);
	}
	return vec_ret;
}

#!perl 

use strict ; 
use feature qw(say);
use List::Util qw(first sum max shuffle maxstr);
use File::Spec::Functions;
use File::Basename qw(dirname basename);

my @arr_fn = qw(
17B029145-1-79.realn.sam
tumor115_target_flank100.bed
1000G_phase1.indels.hg19.vcf
Mills_and_1000G_gold_standard.indels.hg19.vcf 
dbsnp_138.hg19.vcf
); 

my $db = @ENV{'db'}; 


for my $fn_ (@arr_fn)
{
	my $fn = catfile($db, $fn_);
	# print $fn."___" ; 

	if ($fn !~ m/\#/)
	{
		# &sample_small_data($fn);

		&grep_sam_bed_vcf_chr1_100_else_10($fn);
	}
}

# just get some sample 100:10:10 and include the header from a series of files 
sub grep_sam_bed_vcf_chr1_100_else_10($fn)
{

	my $fn = shift;

	my @ret_lines = (); 
	my %hash_chrname = ();
	open my $FP , "<", $fn; 
	my $cnt_all =  -1; 

	my $idx = 0; 
	$idx = 2 if $fn =~ m/\.sam/;
	my $start_save = 0;
	my $inner_cnt = 0;
	my $cnt_r0 = 10;



	while(<$FP>)
	{
		$cnt_all++;	
		my $mul_factor = 1;
		my $e = $_; 
		if ($e =~ m/^\@/ || $e =~ m/^\#/)
		{
			push @ret_lines , $e;
			#print $e;
			next;
		}

		my @t = split m/\t/, $e;
		my $chrname = @t[$idx];

		my $old = keys %hash_chrname;
		@hash_chrname{$chrname}++;
		my $new = keys %hash_chrname;
		
		
		if ($chrname eq "chr1")
		{
			$mul_factor = 10;
		}

		
		
		if ($old != $new)
		{
			$start_save = 1;
			$inner_cnt = 0;
		}

		if ($start_save == 1)
		{

			if ($inner_cnt <= $cnt_r0 * $mul_factor)
			{
				push @ret_lines, $e;
				#print $e;
			}
			else 
			{
				$start_save == 0;
			}
			
			$inner_cnt++;

		}
	}

	close $FP;
	
	open my $FP , ">", q(sample_small_).basename($fn);
	print $FP (join "", @ret_lines);
	close $FP; 

	
	
	
}


if_.seekg(2220);

#perl hash ${ };
	my $hash = 
	{
          '3' => [
                   '4',
                   '3',
                   '0'
                 ],
          '4' => [
                   '1',
                   '3',
                   '2'
                 ],
};

// pthread multithread parallel
#include<iostream>
#include<cstdio>
#include <pthread.h>
#include <vector>

using namespace std;
//pthread_mutex_t m= PTHREAD_MUTEX_INITIALIZER;

static long long total=0;
void* fun(void *p_e)
{
	//pthread_mutex_lock(&m);
	//total += i;
	//pthread_mutex_unlock(&m);

	auto *p_e_ = (int*)p_e;
	p_e_[0] = p_e_[0] * 2;
}

int main(int n_,char ** v_)
{
vector<int> v_i{1,2};
	pthread_t id_thread[55];


	auto len = v_i.size(); 
	auto i = len;
	for (i=0;i<len;i++)
	{
		pthread_create(&id_thread[i],NULL,&fun,&v_i[i]);
	}

	for (i=0;i<len;i++)
	{
		pthread_join(id_thread[i],NULL);
	}


	for (i=0;i<len;i++)
	{
		cout << v_i[i] << endl; 
	}


	return 0;
};

int main()
{
	auto *fn_hg19 = "hg19.fasta0101"; 
	auto *fn_hg19_idx = "hg19.fasta0101.idx";

	ifstream if_(fn_hg19_idx); 
	assert( if_.is_open());
	string e_line;
	while(getline(if_, e_line))
	{
		cout << e_line << endl; 
	}


	if_.close(); 

	return 0;
}


if_.seekg(offset, if_.beg);
 if_.readsome(snp_arr, len);

 // c++ lambda control return fun
auto get_vcf_features = [](char* arr, uint32_t &start, uint32_t &end) -> vector<pair<uint32_t, uint32_t>>

# perl serial to bin from num 
sub serial_arr_2_bin(\@arr)
{
        my $arr_ref = shift;

        for(my $i=0; $i<@$arr_ref; $i++)
        {
                $arr_ref->[$i] = pack("C", $arr_ref->[$i]); 
        }

}

- c++ thread
#include <thread>
        int x = 9;
        int y = 88;
        std::thread td_2(
            [](int &a, int &b)
        {
            cout << a << endl;
            cout << b << endl;
        },
            std::ref(x),
            std::ref(y)
            );
        td_2.join();
-

// cmd parse c++ 

class InputParser {
public:
    InputParser(int &argc, char **argv) {
        for (int i = 1; i < argc; ++i)
            this->tokens.push_back(std::string(argv[i]));
    }
    /// @author iain
    const std::string& getCmdOption(const std::string &option) const {
        std::vector<std::string>::const_iterator itr;
        itr = std::find(this->tokens.begin(), this->tokens.end(), option);
        if (itr != this->tokens.end() && ++itr != this->tokens.end()) {
            return *itr;
        }
        static const std::string empty_string("");
        return empty_string;
    }
    /// @author iain
    bool cmdOptionExists(const std::string &option) const {
        return std::find(this->tokens.begin(), this->tokens.end(), option)
            != this->tokens.end();
    }
private:
    std::vector <std::string> tokens;
};



// st_
int main(int argc, char ** argv)
{
#if 1
    InputParser id_cmd_parse(argc, argv);
    
    cout << id_cmd_parse.cmdOptionExists("-R") << endl;
    cout << id_cmd_parse.getCmdOption("-R") << endl; 
#endif 


// parse cml like : mainapp.exe -R R0 -R R1 -R R2 -L L0
	
class cml_parser
{
public:
    map<string, vector<string>> map_;
    cml_parser(int argc_, char** argv_)
    {
        static vector<string> keys_list{ "-knownSites",  "-R", "-I", "-o", "-L", "-grp" };
        vector<string> vec_arg{};

        auto len = argc_;
        //cout << len << endl;

        for (int i = 0; i < len; i++)
        {
            vec_arg.push_back(string(argv_[i]));
        }

        for (auto &e_key : keys_list)
        {
            vector<string>::iterator it = vec_arg.begin();
            while ((it = std::find(it, vec_arg.end(), e_key)) != vec_arg.end())
            {
                it++;
                map_[e_key].push_back(*it);
                //cout << *it << endl;
            }

        }

    };

    int has_opt(string e_key)
    {
        return map_.find(e_key) == map_.end() ? 0 : 1;
    }
    vector<string> get_arg_opt(string e_key)
    {
        assert(has_opt(e_key));
        return map_[e_key];
    }

};


int main()
{


    
#if 1
    char * argvv[] = {
        "./mainapp.exe",

        "-knownSites", "K0", 
        "-knownSites", "K1", 
        "-knownSites", "K2",
        "-I", "I_V",

        "-o", "o_v", 
        "-L", "L_V",
        "-R", "R_V",
        "-grp", "grp_v",

    };
 
    cml_parser id_cml(17, argvv);

    for (auto &e_map : id_cml.map_)
    {
        cout << e_map.first << endl; 
        for (auto &e_v : e_map.second)
        {
            cout << e_v << " ";
        }
        cout << endl << endl;;
    }


#endif 



// args parse for : mainapp -R R0 R1 R2 -L L0 L1 
class arg_opt
{
public:
    int argc;
    char ** argv;
    int start;
    int offset;
    int end;

    arg_opt(int argc_, char** argv_, int offset_)
    {
        argc = argc_;
        argv = argv_;
        offset = offset_;
    }
    arg_opt() {};
};

class cmd_parser
{
public:

    map<string, arg_opt*> map_;

    vector<arg_opt> vec_opt;


    cmd_parser(int argc_, char ** argv_)
    {

        vector<int> vec_loc_opt{};
        vec_opt.clear();

        for (int i = 0; i < argc_; i++)
        {
            if (argv_[i][0] == '-')
            {
                //cout << string(argv[i]) << endl;
                vec_loc_opt.push_back(i);
            }
        }
        vec_loc_opt.push_back(argc_);
        vec_opt.resize(vec_loc_opt.size() - 1);

        //vec_diff.clear();
        for (int i = 0; i < vec_loc_opt.size() - 1; i++)
        {
            //vec_diff.push_back(vec_loc_opt[i + 1] - vec_loc_opt[i]);
            string key(argv_[vec_loc_opt[i]]);
            int e_argc = vec_loc_opt[i + 1] - vec_loc_opt[i] - 1;
            arg_opt e_opt = arg_opt(e_argc, argv_, vec_loc_opt[i] + 1);
            //cout << "e_argc: " << e_argc  << endl; 
            //cout << key << " " << vec_loc_opt[i] + 1 << endl; 

            vec_opt[i].argc = e_opt.argc;
            vec_opt[i].argv = e_opt.argv;
            vec_opt[i].offset = e_opt.offset;

            vec_opt[i].start = vec_opt[i].offset;
            vec_opt[i].end = vec_opt[i].start + vec_opt[i].argc;

            map_[key] = &(vec_opt[i]);

        }


    }

    ~cmd_parser()
    {
        vec_opt.clear();
        map_.clear();
    }

    int has_opt(string key)
    {
        return map_.find(key) == map_.end() ? 0 : 1;
    }
    arg_opt get_arg_opt(string key)
    {
        assert(has_opt(key));
        return *(map_[key]);
    }
};



int main()
{


   
#if 1

    char * argvv_[] = {
        "./mainapp.exe",

        "-knownSites",
			"K0",
			"K1",
			"K2",
        "-I",
			"I_V",
        "-o",
			"o_v",
        "-L",
			"L_V",
        "-R",
			"R_V",
        "-grp",
			"grp_v",
    };

    cmd_parser id_cml(15, argvv_);

    auto opt_v = id_cml.get_arg_opt("-knownSites"); 

    for (auto t = opt_v.start; t < opt_v.end; t++)
    {
        cout << opt_v.argv[t] << endl;
    }

#endif 


// get thread id of one main thread 	
#include <sys/syscall.h>
#include <sys/types.h>

std::cout << "Hello ! my id is " << (long int)syscall(SYS_gettid) << std::endl;

# get max element in a vector;
cout << *std::max_element(vec_sz.begin(), vec_sz.end(), [](int a, int b) {return a > b; }) << endl;

#string.find("astring", 0) 
cout << "- find:" << (e_line.find("\tchr1\t", 0) == string::npos )<< endl;

 ifstream if_(fn_sam_); assert(if_.is_open());
 if_.seekg(0, ios::end);
 cout << if_.tellg() << endl; 
 if_.close();

	ofstream of_(fn_out_sam, ios::app); assert(of_.is_open());


int  binarySearch_near_smallest_idx(vector<int>& data, int val)
{
    auto high = data.size() - 1;
    
    if (val <= data[0])
        return 0; 

    if ( val >= data[high])
        return data.size() - 1;

    auto low = 0; 

    while (1)
    {

        auto index = (high + low) / 2;


        if (data[index] <= val)
        {
            low = index;

        }
        else 
        {
            high = index;
        }

        if (low >= high - 1)
        {
            return low;
        }


    }



}
  





// st__
int main()
{
    string fn_sam_("E:/jd/t/git/bgi_samtools/bqsr/data/sample_small_realn_17m.sam_bak");
    // string fn_sam_ = "E:/jd/t/db/CL100036475_L01_85.realn_3g.sam";
      //string fn_sam_("E:/jd/t/git/bgi_samtools/bqsr/data/sample_small_17B029145-1-79.realn.sam");
      //parallel_read_sam_2_vec(fn_sam_);

    vector<int> data{ -1, 3, 6,7,33,44, 55, 88, 444, 555 };

    assert(binarySearch_near_smallest_idx(data, -1) == 0);
    assert(binarySearch_near_smallest_idx(data, 6) == 2);
    assert(binarySearch_near_smallest_idx(data, 9) == 3);
    assert(binarySearch_near_smallest_idx(data, 55) == 6);
    assert(binarySearch_near_smallest_idx(data, 57) == 6);
    assert(binarySearch_near_smallest_idx(data, 47) == 5);
    assert(binarySearch_near_smallest_idx(data, 87) == 6);


    __P__;
}


#pragma pack(1)
struct vcf_range
{
    uint64_t pos;
    uint16_t len;
};

#pragma pack()


int  bin_search_nearest_smaller_idx(vcf_range* arr_vcf_range, int sz, int val)
{
    auto high = sz - 1;

    if (val <= arr_vcf_range[0].pos)
        return 0;

    if (val >= arr_vcf_range[high].pos)
        return sz - 1;

    auto low = 0;


    while (1)
    {
        
        auto index = (high + low) / 2;

        if (arr_vcf_range[index].pos <= val)
        {
            low = index;
        }
        else
        {
            high = index;
        }

        if (low >= high - 1)
        {
            return low;
        }
     
    }


}




// st__
int main()
{
    string fn_sam_("E:/jd/t/git/bgi_samtools/bqsr/data/sample_small_realn_17m.sam_bak");
    // string fn_sam_ = "E:/jd/t/db/CL100036475_L01_85.realn_3g.sam";
      //string fn_sam_("E:/jd/t/git/bgi_samtools/bqsr/data/sample_small_17B029145-1-79.realn.sam");
      //parallel_read_sam_2_vec(fn_sam_);
    vcf_range arr_vcf_range[] =
    {
        { 243071988, 1 },
        { 243072040, 4 },
        { 243072065, 1 },
        { 243072227, 1 },
        { 243072234, 1 },
        { 243072268, 1 },
        { 243072440, 1 },
        { 243072441, 1 },
        { 243072444, 1 },
        { 243072460, 1 },
        { 243072658, 1 },
        { 243072658, 3 },
        { 243072661, 1 },
        { 243072679, 1 },
        { 243072682, 1 },
        { 243072689, 4 },
    };

    auto sz = 339-324+1;
    uint64_t val = 243072658 + 1;
    cout << bin_search_nearest_smaller_idx(arr_vcf_range, sz, val) << endl;

    __P__;
}


alias grep='grep --color'

# to output status 
#val 

#define calltest(val)  test ((val), #val)

void test(int res, char const * const func)
{
    printf("%d, %s", res, func);
}

int return_int(int abc)
{
    return abc*abc;
}
int main()
{
    int abc = 9; 
    calltest(return_int(abc));

}
// end 


#if 1 
	/*	
		dim3 dimGrid(1, 2);
		dim3 dimBlock(3, 4, 5);
		testKernel<<<dimGrid, dimBlock>>>(10);
	 */

#define JD_TID(I,J,COLS, i,j,k,rows,cols,channels)  (((I)*(COLS)+(J)) * ((rows)*(cols)*(channels)) + ((i)*(cols)+(j)) * (channels) + (k))
#define _TID(I,J, i,j,k)  (((I)*(COLS)+(J)) * ((rows)*(cols)*(channels)) + ((i)*(cols)+(j)) * (channels) + (k))
#define __TID(I,J, i,j,k)  (((I)*(gridDim.x)+(J)) * ((blockDim.y)*(blockDim.x)*(blockDim.z)) + ((i)*(blockDim.x)+(j)) * (blockDim.z) + (k))

	auto &I = blockIdx.y; 
	auto &J = blockIdx.x; 
	auto &COLS = gridDim.x; 
	//auto &ROWS = gridDim.y; 

	auto& i = threadIdx.y; 
	auto& j = threadIdx.x; 
	auto& k = threadIdx.z; 
	auto &cols = blockDim.x;
	auto &rows = blockDim.y;
	auto &channels = blockDim.z;

	auto jd_tid = JD_TID(I,J,COLS, 	i,j,k,rows,cols,channels);
	printf("jd_tid : %d\n", jd_tid); 


#endif 



#if 0
	/*	
		dim3 dimGrid(1, 2);
		dim3 dimBlock(3, 4, 5);
		testKernel<<<dimGrid, dimBlock>>>(10);
	 */
#define __TID(I,J,K, i, j, k)  ((((I)*(gridDim.x)+(J))*(gridDim.z)+ (K))* (blockDim.x)*(blockDim.y)*(blockDim.z)+ ((i)*(blockDim.x)+(j))*(blockDim.z) + (k))
	auto &I = blockIdx.y; 
	auto &J = blockIdx.x; 
	auto &K = blockIdx.z;
	
	auto& i = threadIdx.y; 
	auto& j = threadIdx.x; 
	auto& k = threadIdx.z; 
	
	auto jd_tid = __TID(I,J,K, i, j, k);
	printf("%d\n", jd_tid); 
#endif 


#endif 

https://shimo.im/docs/1aNb00H6dHQaVnL3



//---------- cuda sample vector opt -----------------------

### cuda on matrix ###
/*
* Copyright 1993-2015 NVIDIA Corporation.  All rights reserved.
*
* Please refer to the NVIDIA end user license agreement (EULA) associated
* with this source code for terms and conditions that govern your use of
* this software. Any use, reproduction, disclosure, or distribution of
* this software and related documentation outside the terms of the EULA
* is strictly prohibited.
*
*/

#pragma diag_suppress 177
// System includes
#include <stdio.h>
#include <cassert>



// CUDA runtime
#include <cuda_runtime.h>

// helper functions and utilities to work with CUDA
#include <helper_functions.h>
#include <helper_cuda.h>
#include <helper_math.h>

// jd add
#define DEL_ARR_MEM(P) if(NULL != (P)){delete [] (P); (P) = NULL;}

#ifdef __linux__
#define __P__  return 0;   //__
#else
#define __P__  system("pause");return 0;   //__
#define popen(fp, fr) _popen((fp),(fr))
#define pclose(fp) _pclose(fp)
#endif
#define CUDA_CHECK_RETURN(value) CheckCudaErrorAux(__FILE__,__LINE__, #value, value)

#define __TID(I,J,K, i, j, k)  ((((I)*(gridDim.x)+(J))*(gridDim.z)+ (K))* (blockDim.x)*(blockDim.y)*(blockDim.z)+ ((i)*(blockDim.x)+(j))*(blockDim.z) + (k))

#define GET_TID  __TID(_I,_J,_K, _i, _j, _k)
#define DEFINE_I_J_K auto &_I = blockIdx.y; \
            auto & _J = blockIdx.x; \
            auto & _K = blockIdx.z; \
            auto & _i = threadIdx.y; \
            auto & _j = threadIdx.x; \
            auto & _k = threadIdx.z; \
            auto & _COLS = gridDim.x; \
            auto & _ROWS = gridDim.y; \
            auto & _CHANNELS = gridDim.z; \
            auto & _cols = blockDim.x; \
            auto & _rows = blockDim.y; \
            auto & _channels = blockDim.z;

#define DEFINE_I_J_K_idx  DEFINE_I_J_K;auto idx = GET_TID;
            

static void CheckCudaErrorAux(const char *file, unsigned line, const char *statement, cudaError_t err)
{
    if (err == cudaSuccess)
        return;
    std::cerr << statement << " returned " << cudaGetErrorString(err) << "(" << err << ") at " << file << ":" << line << std::endl;
    system("pause"); 
    exit(1);
}

#include <iostream>
#include <numeric>
#include <stdlib.h>

using std::cout; 
using std::endl;
// jd end 

#ifndef MAX
#define MAX(a,b) (a > b ? a : b)
#endif


static const int rows = 4;
static const int cols = 5;

//static int global_int_a = 0;

__device__ __host__ 
inline float ker_opt(float &f, int idx)
{
    return 2.0f * f + idx * 0.0f;
}

#if 0
__device__
class A
{
public:
    __device__ inline A()
    {
        x = 1; 
        y = 9;
    }
    __device__ inline ~A() {}
    int x; 
    int y; 


};
#endif 

extern __shared__ char abc[]; 



__global__ void testKernel(float *gpu_data_input, float *gpu_data_output, int size)
{
#if 1
    DEFINE_I_J_K_idx;


    auto &idx_v = gpu_data_output[idx] = ker_opt(gpu_data_input[idx], idx);

    if (_J == 0 || _J == _COLS - 1 || _j == 0 || _j == _cols - 1)
    {
        idx_v = 0;
    }

    if (_J == _j)
    {
        idx_v = 0;
    }

#endif 

}



float * initialize_raw_data()
{
    auto size = rows * cols;
    float *raw_data = new float[size];
    assert(NULL != raw_data);
    for (auto i = 0; i < size; ++i)
    {
        raw_data[i] = i * 1.0f;
    }
    
    return raw_data;
    
}

float * cpu_cal(float *raw_data)
{
    auto size = rows * cols; 
    float *cpu_ret = new float[size];
    assert(NULL != cpu_ret);
    for (auto cnt = 0; cnt < size; cnt++)
    {
        cpu_ret[cnt] = ker_opt(raw_data[cnt], cnt);
    }
    return cpu_ret;
}



float *gpu_cal(float *raw_data)
{



    cudaError_t error;
    auto size = rows * cols; 

    float *gpu_raw_data_input = NULL;
    float *gpu_raw_data_output = NULL;
    float *p_ret = new float[size];
    assert(NULL != p_ret);

    CUDA_CHECK_RETURN(cudaMalloc((void **)&gpu_raw_data_input, sizeof(float)*size));
    CUDA_CHECK_RETURN(cudaMalloc((void **)&gpu_raw_data_output, sizeof(float)*size));
    CUDA_CHECK_RETURN(cudaMemcpy(gpu_raw_data_input, raw_data, sizeof(float)*size, cudaMemcpyHostToDevice));


#if 0
    dim3 dimGrid(rows, 1, 1);
    dim3 dimBlock(cols, 1, 1);
    uint Ns = 1024;
#endif 
#if 1
    dim3 dimGrid(rows, 1, 1);
    dim3 dimBlock(cols, 1, 1);
    uint Ns = 1024;
#endif 



    



    testKernel<<<dimGrid, dimBlock, Ns*sizeof(char)>>>(gpu_raw_data_input, gpu_raw_data_output, size);
    //testKernel <<<dimGrid, dimBlock, Ns*sizeof(char) >>>(arr_gpu_raw_data_input, arr_gpu_raw_data_output, size);

    
    //Synchronize (flushes assert output).
 



    error = cudaDeviceSynchronize();


    //Check for errors and failed asserts in asynchronous kernel launch.
    if (error == cudaErrorAssert)
    {
        printf("\n-- Begin assert output\n\n");
        printf("Device assert failed as expected, CUDA error message is: %s\n\n",  cudaGetErrorString(error));
        printf("\n-- End assert output\n\n");
        system("pause");
    }

    
    //testResult = error == cudaErrorAssert;

    CUDA_CHECK_RETURN(cudaMemcpy(p_ret, gpu_raw_data_output, sizeof(float)*size, cudaMemcpyDeviceToHost));
    CUDA_CHECK_RETURN(cudaFree(gpu_raw_data_input));
    CUDA_CHECK_RETURN(cudaFree(gpu_raw_data_output));
    return p_ret;
}

void show_cuda_info(int flag_show)
{

    int devID;
    cudaDeviceProp props;

    // This will pick the best possible CUDA capable device
    int argc = 0; 
    char ** argv = NULL;
    devID = findCudaDevice(argc, (const char **)argv);

    //Get GPU information
    CUDA_CHECK_RETURN(cudaGetDevice(&devID));
    CUDA_CHECK_RETURN(cudaGetDeviceProperties(&props, devID));
    
    (flag_show)&& printf("Device %d: \"%s\" with Compute %d.%d capability\n", devID, props.name, props.major, props.minor);

    (flag_show)&& printf("printf() is called. Output:\n\n");

}


__device__ __managed__ int arr_0[9]; 
// st__
int main(int argc, char **argv)
{

    show_cuda_info(0);


    //jd add
    float *raw_data = initialize_raw_data();   // mem 0

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            auto &t = raw_data[i*cols + j] = (i*cols + j) * 1.0f; 

            printf("%4d ", (int)t);
        }
        cout << endl;


    }


    float *cpu_ret = cpu_cal(raw_data); // mem 1
    float *gpu_ret = gpu_cal(raw_data); // mem 2
    
    cout << endl; 
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            auto &t = gpu_ret[i*cols + j]; // = (i + j) * 1.0f;
            printf("%4d ",  (int)t);
        }
        cout << endl; 
    }

    DEL_ARR_MEM(raw_data); // del 0

    float cpu_sum = std::accumulate(cpu_ret, cpu_ret + rows * cols, 0.0f);
    float gpu_sum = std::accumulate(gpu_ret, gpu_ret + rows * cols, 0.0f);

#if 0
    for (int i = 0; i < rows * cols; i++)
    {
        cout << i << ": " << cpu_ret[i] << endl;
        cout << i << ": " << gpu_ret[i] << endl; 
        cout << endl; 
    } 
    printf("%f == %f\n", cpu_sum, gpu_sum);
#endif 
    

    DEL_ARR_MEM(cpu_ret); // del 1
    DEL_ARR_MEM(gpu_ret); // del 2

   


    //jd end 

    //return EXIT_SUCCESS;
    __P__;
}


//static const int rows = ((1 << 19) - 1 )/1000;  // 524287
//static const int cols = 1024;


### sscanf to parse string to number int float 

    string abc = "5.6    6.77778  8888.88887"; 
    std::string::size_type sz = 0; 
    auto sz_cache = sz; 
    
    char buf_0[12];
    char buf_1[12];
    char buf_2[12];

    sscanf(abc.c_str(), "%11s%11s%11s", buf_0, buf_1, buf_2);

    printf("___%f___\n", atof(buf_0) + 1000000.0);
    printf("___%f___\n", atof(buf_1) + 1000000.0);
    printf("___%f___\n", atof(buf_2) + 1000000.0);

# access or delete old file , of_0, clear old content 
    ofstream of_0(fn_out_sam.c_str(), ios::binary); assert(of_0.is_open()); of_0.close();
	ofstream of_(fn_out_sam.c_str(), ios::app); assert(of_.is_open());
//#include "common.hpp"
/*
 * jd create at 2018-02-28
 * to build & run on Linux, just run :
 * make
 */
//#pragma once
#pragma warning(disable:4996)
#pragma warning(disable:4018)

#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <stdint.h>  // uint64_t
#include <assert.h>

#include <vector>
#include <sstream>
//#include <unordered_map>
#include <map>
#include <algorithm>    // std::sort
#include <utility>

#include <stack>
#include <memory.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <errno.h>
#include <time.h>
//#include <thread>
//#include <mutex>

#if __linux___
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <htslib/faidx.h>
#include <strings.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include "htslib/tbx.h"
#include "htslib/sam.h"
#include "htslib/vcf.h"
#include "htslib/kseq.h"
#include "htslib/bgzf.h"
#include "htslib/hts.h"
#include "htslib/regidx.h"
#include <unordered_map>
#include <iomanip>
#include <list>
#include "hfile_internal.h"
#include <unistd.h>
#include <sys/time.h>
#include <numeric>
#include <float.h>

#endif


#ifdef __linux__
#define __P__  return 0;   //__
#else
#define __P__  system("pause");return 0;   //__
#define popen(fp, fr) _popen((fp),(fr))
#define pclose(fp) _pclose(fp)
#endif

#define DEL_ARR_MEM(P) if(NULL != (P)){delete [] (P); (P) = NULL;}
#define DEBUG 1 //DEBUG=1, use debug version, vice versa.
#define FLAG_USE_MULTI_THREAD 0 //thr_, FLAG_USE_MULTI_THREAD = 0, single thread; FLAG_USE_MULTI_THREAD = 1, MultiThread.
#define E_BATCH_NUM_BR 40000  //e_batch_num_br = 10000
#define TD_NUM_BR 4 //td_num_br = 20
#define E_BATCH_NUM_PR 1 //e_batch_num_pr = 10000
#define TD_NUM_PR 1 //td_num_pr = 20

#define AUTOTEST 0
#define br_Ana 0 //br_Ana = 1, pr_Ana = 0, only run br; br_Ana = 1, pr_Ana = 1, both no run.
#define pr_Ana 1 //br_Ana = 0, pr_Ana = 1, only run pr; br_Ana = 0, pr_Ana = 0, both run.

#define dq_adv 1 //dq_adv = 1, advanced computing of deltaQ
#define should_have_argc 13


using namespace std;

template<typename T>
string to_string_(T n){
        ostringstream ss;
        ss << n ;
        return ss.str();

}

#define S_(x) to_string_((long int)(x))

// main_
int main(int argc, char **argv)
{

        for (int i=0;i<1e5;i++)
        {

                int a = 99;
                string env_n = "env_n";
                string env_statement = env_n + "=" + S_(&a);

                //cout <<  env_statement << endl;

                putenv(&env_statement[0]);

                char *env_n_str = &env_n[0];
                //printf("env_n=%s" "\n", getenv(env_n_str));
                //cout << endl;

                int aa  = *(int*)(atol(getenv(env_n_str)));
                //cout << aa << endl;
                assert( a== aa);
        }
        return 0;
}

cout << "01234"[2] << endl; 

// get time , in pure c code , no cv time diff 
#if 1 	
	//{
	//#include <time.h>
	auto diff_in_seconds_jd = [](timeval *end, timeval *start)
	{
		double sec;
		sec=(end->tv_sec - start->tv_sec);
		sec+=(end->tv_usec - start->tv_usec)/1000000.0;
		return sec;
	};

	struct timeval start, end;
	gettimeofday (&start, NULL);
	system("sleep 2s"); 
	gettimeofday (&end, NULL);
	auto time_used = diff_in_seconds_jd(&end, &start); 
	printf("- time used : %f\n", time_used); 

	//}
#endif 

#include <time.h>
	fprintf(stderr, "%.2f sec\n", (float)(clock() - t) / CLOCKS_PER_SEC);

Wed Nov 14 16:20:43 CST 2018
*********************
repair_cuda_8_0.sh
*********************
sudo /usr/local/cuda-8.0/bin/uninstall_cuda_8.0.pl
sudo /usr/bin/nvidia-uninstall
sudo sh cuda_8.0.61_375.26_linux.run
nvidia-smi

EOF

                dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
                java.util.Date date_end = new java.util.Date();
                logger.info("Date/Time: " + dateFormat.format(date_end));

                long diffInMillies = Math.abs(date_end.getTime() - date_start.getTime());
                long diff = TimeUnit.SECONDS.convert(diffInMillies,TimeUnit.MILLISECONDS);
                logger.info("- Time Diff: " + diff + " s");

reserve is bytes, resize is N * sizeof(A);

#if 1
    vector<int> a{};
    a.resize(1);   // if use a.reserve, will error 
    a[0] = 77; 
#endif

#if 0
	auto td_0_0 = std::thread([](int &x, int &y) {printf("- 0: %d, %d\n", x, y); }, std::ref(x), std::ref(y));
	auto td_0_1 = std::thread([](int &x, int &y) {printf("- 1: %d, %d\n", x, y); }, std::ref(x), std::ref(y));

	td_0_0.join();
	td_0_1.join();
#endif 



#if 1

   // split data , and use that in each_thread 

    vector<std::pair<int, int> > arr_pair_i_i{};
    
    const int N = 2e2 + 1;
    int mod_num = 200;
    arr_pair_i_i.resize( N % mod_num == 0? N/mod_num : N/mod_num + 1);

    int cnt = 0;
    int cnt_arr = 0;


    


    while (cnt < N)
    {

            //cout << cnt << endl;
            auto& e_pair = std::make_pair(cnt, cnt + mod_num > N ? N : cnt + mod_num);
            arr_pair_i_i[cnt / mod_num] = e_pair;
            //cnt_arr++;
        cnt += mod_num;
    }

   // cout << cnt << endl; 

    for (auto &e : arr_pair_i_i)
    {
        cout << "[" << e.first << " => " << e.second << ")" << endl; 
    }


    vector<float> arr_src{};
    arr_src.resize(N); 
    cnt = 0; 
    for (auto &e : arr_src)
    {
        e = cnt++;
    }

#if 1
    int id_td = 0; 
    for (auto &e_args : arr_pair_i_i)
    {
       
        auto e_td = std::thread(
            /* exec_e_td() */
            [](vector<float> &arr_src, std::pair<int, int>& pair_i_i, int& id_td) {


            cout << "- id_td: " << id_td << endl; 
            system("sleep 1s");
            for (int i = pair_i_i.first; i < pair_i_i.second; i++)
            {
                cout << arr_src[i] << " ";
            }
            cout << endl;
        },
            std::ref(arr_src),
            std::ref(e_args), 
            std::ref(id_td)
            );

        e_td.detach();
        id_td++;
    }
#endif 
        
    cnt = 5;
    while (cnt--)
    {
        system("sleep 1s");
    }


#endif 



/////////// c++ multithread framework //////////////

template<typename T> string tools_to_string(const T &t)
{
	ostringstream ss;
	ss << t;
	return ss.str();
}


void exec_e(float &e)
{
	//cout << e << " ";
	e *= 10.0f;
	e += 0.1f;
}



void exec_multi_threads_on_data(vector<float>& arr_src, const int& N, const int& td_num, void (*cb)(float &e))
{

#define FLAG_USE_MULTIPLE_THREAD_ 0 

#define FLAG_USE_SINGLE_THREAD_ (!FLAG_USE_MULTIPLE_THREAD_) 


	//typedef  pair<int, std::thread> i_td;
	//int td_num_real = td_num - 1; 
	int mod_num = ceil (N * 1.0f / td_num );
	vector< pair<int, std::thread> > arr_pair_i_td{};

	arr_pair_i_td.resize(td_num);

	//arr_pair_i_td.resize(N % mod_num == 0 ? N / mod_num : N / mod_num + 1);

	int cnt = 0;
	int cnt_arr = 0;

	cnt = 0;
	int flag_break_at_pad = 0;
	int cnt_threads = 0; 
	for(int i=0;i<td_num;i++)
	{
		auto id_td = i; 
		int start ; 
		int end; 
		if(i*mod_num + mod_num <= N)
		{
			end = i * mod_num + mod_num; 
		}
		else
		{
			int pad_num = N % mod_num; 
			end = i * mod_num + pad_num; 
			flag_break_at_pad = 1; 
		}
		start = i * mod_num; 


		cnt_threads++; 
		auto pair_i_i = make_pair(start, end);
		//auto pair_i_i = make_pair(cnt, cnt + mod_num > N ? N : cnt + mod_num);


		arr_pair_i_td[id_td].first = id_td;
		arr_pair_i_td[id_td].second = thread([&cb](int id_td, vector<float>& arr_src, pair<int, int> pair_i_i) {

#if 1
				float sleep_time_seconds = id_td * 0.02f;
				string cmd_sleep = string("sleep ") + tools_to_string(sleep_time_seconds) + "s";
				system(cmd_sleep.c_str());
				//cout << cmd_sleep << endl; 
#endif 
				cout << "- id_td: " << id_td << endl;

				for (auto i = pair_i_i.first; i < pair_i_i.second; i++)
				{
				//cout << arr_src[i] << " ";
				cb(arr_src[i]);
				}
				//cout << endl << "--------------------" << endl;

				},
				id_td, std::ref(arr_src), pair_i_i
				);





#if FLAG_USE_SINGLE_THREAD_
		cout << "- FLAG_USE_SINGLE_THREAD_ " << endl; 
		arr_pair_i_td[id_td].second.join();
#endif 

		if (flag_break_at_pad) break; 
	}

	cout << "- cnt_threads : " << cnt_threads << endl; 

#if FLAG_USE_MULTIPLE_THREAD_  
	for (auto& e_pair : arr_pair_i_td)
	{
		e_pair.second.join();
	}

#endif


	arr_pair_i_td.clear();





}



// st__ main_
int main(int argc, char **argv)
{
	const int N = (const int)(1e8 + 0);
	const int td_num = 30; 


	vector<float> arr_src{};
	arr_src.resize(N);
	int  cnt = 0;
	for (auto &e : arr_src)
	{
		e = (cnt++) * 1.0f;
	}

	exec_multi_threads_on_data(arr_src, N, td_num, exec_e);

	cout << arr_src[1] << endl; 
	cout << arr_src[N - 1] << endl; 

	arr_src.clear(); 



	__P__;
}

// read file to fc , and then split it to vector string

vector<string> split_str_2_vec(const string & str, const char & delimiter = '\t', const int & retainNum = -1, int flag_push_tail_str = 0);
vector<string> split_str_2_vec(const string & str, const char & delimiter, const int & retainNum, int flag_push_tail_str)
{
    std::vector<std::string>   vec_ret{};
    vec_ret.reserve(16);

    std::stringstream  data(str);

    std::string line;
    if (retainNum == -1)
    {
        if (delimiter == ' ')
        {
            while (std::getline(data, line, delimiter)) // assume
            {
                // Note: if multiple delimitor in the source string,
                //           you may see many empty item in vector
                if (line == "") continue;
                vec_ret.push_back(line);
            }
            return vec_ret;
        }
        while (std::getline(data, line, delimiter))     // assume
        {
            // Note: if multiple delimitor in the source string,
            //       you may see many empty item in vector
            vec_ret.push_back(line);
        }
    }
    else
    {
        if (delimiter == ' ')
        {
            int cnt = 0;
            while (std::getline(data, line, delimiter)) // assume
            {
                if (cnt >= retainNum) break;
                if (line == "") continue;
                vec_ret.push_back(line);
                cnt++;
            }
            return vec_ret;
        }
        int cnt = 0;
        while (cnt < retainNum && std::getline(data, line, delimiter))     // assume
        {
            //if (cnt >= retainNum) break;
            vec_ret.push_back(line);
            cnt++;
        }
    }

    if (flag_push_tail_str)
    {
        std::getline(data, line, '\a');
        vec_ret.push_back(line);
    }
    return vec_ret;
}



// st__ main_
int main(int argc, char **argv)
{



#if 1

    ifstream if_("E:/jd/t/1.txt");

    assert(if_.is_open()); 
  
    std::stringstream fc_;
    fc_ << if_.rdbuf(); 
    auto &fc = fc_.str();


   cout << "___" << fc << "___" << endl;

   auto id_v = split_str_2_vec(fc, ' ', 3);
   for (auto &e : id_v)
   {
       cout << "___" << e << "___" << endl;
   }
    
    if_.close();


#endif 

} 
// std::transform 

#if 1
    string e_str = "ABCD";
    string e_str_ = std::string(e_str);

    std::transform(e_str.begin(), e_str.end(), e_str_.begin(), [](char e_c) {return e_c + 1; });
    cout << e_str << endl; 
    cout << e_str_ << endl; 
#endif

// a way to use range R in c++
#define R(N) vector<int>(arr + 0, arr + N)
#define range(M,N) vector<int>(arr + M, arr + N)



// st__ main_
int main(int argc, char **argv)
{

#if 1

    int arr[1024] = { 0 };
    int cnt = 0;
    for (auto &e : arr)
    {
        e = cnt++;
    }

    for (auto i : R(9))
    {
        cout << i << endl; 
    }
    
#endif

}

// std error stderr 
std::cerr << endl << "- cnt_bad_base : " << cnt_bad_base << endl;


// c++ calculate crc crc64
const int sz_crc = 256;
uint64_t table[sz_crc];
void generate_crc_table()
{
    uint64_t poly = 0xC96C5795D7870F42;
    for (int i = 0; i<sz_crc; ++i)
    {
        uint64_t crc = i;

        for (int j = 0; j<8; ++j)
        {
            // is current coefficient set?
            if (crc & 1)
            {
                // yes, then assume it gets zero'd (by implied x^64 coefficient of dividend)
                crc >>= 1;

                // and add rest of the divisor
                crc ^= poly;
            }
            else
            {
                // no? then move to next coefficient
                crc >>= 1;
            }
        }

        table_crc[i] = crc;
    }
}


uint64_t calculate_crc(const string& stream)
{

    uint64_t crc = 0;
    auto n = stream.size();
    for (int i = 0; i<n; ++i)
    {
        auto index = stream[i] ^ crc;
        uint64_t lookup = table_crc[index];

        crc >>= 8;
        crc ^= lookup;
    }

    return crc;
}




#endif 

// st__ main_
int main(int argc, char **argv)
{

#if 1
    generate_crc_table();
    cout << calculate_crc(string("xxxxx")) << endl;;




#endif
}

// run_cmd() c++ 
string run_cmd(const string& cmd)
{
    FILE *pf = popen(cmd.c_str(), "r");
    const int TO_READ_SZ = 1023;
    const char end_c = '\n';
    string res = string(TO_READ_SZ + 1, end_c);

    if (0 != fread((void*)(res.data()), TO_READ_SZ, 1, pf))
    {
        printf("- cannot run system cmd %s\n", cmd.c_str());
        pclose(pf);
        assert(0 == 1);
        return string("NULL");
    };
    pclose(pf);
    res.erase(res.find_last_not_of(" \n\r\t\0") + 1);
    return res;
}

#include <deque>
#include <queue>


// st__ main_
int main(int argc, char **argv)
{

#if 1
    ifstream if_("./data/1.fq"); assert(if_.is_open());
    
    std::queue<string> q_s; 
    
    string es = "NULL"; 

    while (std::getline(if_, es))
    {
        q_s.push(es);
    }


    while (!q_s.empty())
    {
       
        cout << q_s.front() << endl;
        q_s.pop();
        break;
    }
    if_.close();
#endif 
}

// read and process each line simutenously , parallelly 
#include <deque>
#include <queue>

// st__ main_
int main(int argc, char **argv)
{


#if 1
    int N = 9;
    vector<string> v_s; 
    v_s.resize(N); 

    vector<string> v_s_copy;
    v_s_copy.resize(N);

    int cnt = 0;
    int round = 0;
    ifstream if_("./data/1.txt"); assert(if_.is_open());
    string es;

    auto deal_with_v_s = [](vector<string>* p_v_s_) 
    {
       
        sleep(100 * 1e-3);
        for (auto &e : *p_v_s_)
        {
            cout << e.substr(0, 11) << endl;
        }
        cout << endl; 
    };

    auto *p_v = &v_s; 

    thread id_t0;

    while ( std::getline(if_, es) )
    {
        if (cnt == N)
        {
            cnt = 0;
            
            if (id_t0.joinable())
            {
               
                id_t0.join();
            }

            id_t0 = thread(deal_with_v_s, p_v);
            
            if (round % 2 == 1)
            {
                p_v = &v_s;
            }
            else
            {
                p_v = &v_s_copy;
            }
            
            round++;
        }

        (*p_v)[cnt] = es;     
        cnt++;
    }

    if_.close();


// this is a thread need joinable
    if (id_t0.joinable())
    {
        cout << "- in last joinable\n";
        id_t0.join();
    }


    // for the tail group
    cout << "- in tail\n";
    for (int i = 0; i < cnt; i++)
    {
        cout << (*p_v)[i].substr(0,11) << endl;
    }


#endif 

}

#if 1
//#include <conio.h>
#define KEY_UP 72
#define KEY_DOWN 80
#define KEY_LEFT 75
#define KEY_RIGHT 77
    int c = 0;
    while (1)
    {
        c = 0;

        switch ((c = getch())) {
        case KEY_UP:
            cout << endl << "Up" << endl;//key up
            break;
        case KEY_DOWN:
            cout << endl << "Down" << endl;   // key down
            break;
        case KEY_LEFT:
            cout << endl << "Left" << endl;  // key left
            break;
        case KEY_RIGHT:
            cout << endl << "Right" << endl;  // key right
            break;
        default:
            cout << endl << "null" << endl;  // not arrow
            break;
        }

    }

    return 0;


#endif 

### perl key getchar getc byte
#!/usr/bin/perl -w

use strict;
use warnings;

use IO::Handle;

eval {
    my $stdin = new IO::Handle;
       $stdin->fdopen( fileno( STDIN ), "r" ) || die "Cannot open STDIN";

    system "stty -icanon -isig -echo min 1 time 0";
    my $escape;
    my $ctrl;
    my $function;

    while ( my $char = $stdin->getc() ) 
	{

        if ( ord( $char ) == 27 ) {             # Escape character
            $escape = 1;
            print "ESC + ";
            next;
        }
        if ( $escape && ord( $char ) == 91 ) {  # Control character
            $ctrl = 1;
            print "CTRL + ";
            next;
        }

        if ( $escape && $ctrl && $function && ord( $char ) == 126 ) {
            undef $escape;                      # Clean up after Fnctn key
            undef $ctrl;
            undef $function;
            next;
        }

        if ( $escape && $ctrl && !$function ) {
            print "Up\n"     if ( ord( $char ) == 65 );  # up
            print "Down\n"   if ( ord( $char ) == 66 );  # down
            print "Right\n"  if ( ord( $char ) == 67 );  # right arrow
            print "Left\n"   if ( ord( $char ) == 68 );  # left arrow
            if ( ord( $char ) == 49 ) {                  # Function character
                $function = 1;
                print "FCN + ";
            } else {                                     # Clean up for arrow keys
                undef $escape;
                undef $ctrl;
            }
            next;
        }

        if ( $escape && $ctrl && $function ) {
            print "F5\n"     if ( ord( $char ) == 53 ); # F5 key
            print "F6\n"     if ( ord( $char ) == 55 ); # F6 key
            print "F7\n"     if ( ord( $char ) == 56 ); # F7 key
            print "F8\n"     if ( ord( $char ) == 57 ); # F8 key
                                                        # wait for clean up char
            next;
        }

        if ( $escape && !$ctrl && !$function ) {
            print "F1\n" if ( ord( $char ) == 80 );  # F1 key
            print "F2\n" if ( ord( $char ) == 81 );  # F2 key
            print "F3\n" if ( ord( $char ) == 82 );  # F3 key
            print "F4\n" if ( ord( $char ) == 83 );  # F4 key
            undef $escape;                           # Clean up
            next;
        }

        print "Return\n" if ( ord( $char ) == 10 );  # return key
        print "Delete\n" if ( ord( $char ) == 127 ); # delete key
        print "Tab\n"    if ( ord( $char ) == 9 );   # tab key
        next             if ( ord( $char ) == 32 );  # skip on space key
        last             if ( $char =~ /q/ );        # break on q
        last             if ( $char =~ /\003/ );     # break on Ctrl-C
        last             if ( $char =~ /\032/ );     # break on Ctrl-Z
        print "ord: " . ord($char) . "\n";
    }
    system "stty icanon echo isig";
    exit(0);
};

if ( $@ ) {
    print "$@\n";
    system "stty icanon echo isig";
    exit(1);
}



    auto trim_string = [](std::string const &s)
    {
        if (s.empty()) 
        {
            return s;
        }

        s.erase(0,s.find_first_not_of(" "));
        s.erase(s.find_last_not_of(" ") + 1);
    };

// cin getline 
    string e = "NULL"; 

    //cin >> e; 
    getline(cin, e);
    cout << "___" << e << "___" << endl; 
 char a = 'a'; 
string s_a = string("") + a; 

    char a = 'a';
    auto sa= to_string(a);



# putenv c++ , must not call in function
inline int  env_it(const char* v_name_0, string var_0, const char* v_name_1, string var_1, bool flag_output=false)
{
    //auto  stm = string(v_name) + string("=") + var;

    //auto v_name = "s"; 
    //auto var =s ;
    auto stm_0 = string(v_name_0) + "=" + var_0; 
    auto ret_code_0 =  putenv((char*)(stm_0.c_str()));

    auto stm_1 = string(v_name_1) + "=" + var_1; 
    auto ret_code_1 =  putenv((char*)(stm_1.c_str()));

    assert(0== ret_code_0);
    assert(0== ret_code_1); 
    

    if (flag_output)
    {
        cout << stm_0 << endl; 
        cout << stm_1 << endl; 
        cout << endl;
        auto t_0 = getenv(v_name_0); 
        cout << string(v_name_0) << ":" <<string(t_0) << endl; 

        auto t_1 = getenv(v_name_1); 
        cout << string(v_name_1) << ":" <<string(t_1) << endl; 
        
    }

    //system(" perl -e 'print q{OK 0 }; print $ENV{" "s" "};' ");
    //system(" perl -e 'print q{OK 0 }; print $ENV{" "a" "};' ");


    system("which ls");


    system(
            " perl -e \' \
            $_______________________________; \
            $a=$ENV{a}; \
            $s=$ENV{s}; \
            @arr=split //,$s; \
            %h =(); \
            for(@arr){$h{lc($_)}++}; \
            print $h{lc($a)};\
            $_______________________________; \
            \'  "
          );


    return 0==ret_code_0 && 0==ret_code_1; // 1:OK
}


// putenv , call in function, only work on windows
void env_it(const char* v_name, string var)
{
    // only work on windows
    auto  stm = string(v_name) + string("=") + var;
    auto ret_code = putenv((char*)(stm.c_str()));
    assert(0 == ret_code);
}


int main()
{
#if 1
   
    string s;
    getline(cin, s);

    char a = 0;
    cin >> a;

    env_it("s", s);
    env_it("a", string("")+a);

    system(
        " perl -e \" \
                     $_______________________________; \
                     $a=$ENV{a}; \
                     $s=$ENV{s}; \
                     @arr=split //,$s; \
                     %h =(); \
                     for(@arr){$h{lc($_)}++}; \
                     print $h{lc($a)};\
                     $_______________________________; \
                     \"  "
        );

#endif

}

/*
 * jd create at 2019-07-08
 * to build & run on Linux, just run :
 * make run
 */
//#pragma once
#pragma warning(disable:4996)
#pragma warning(disable:4018)

#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <stdint.h>  // uint64_t
#include <assert.h>

#include <vector>
#include <sstream>
#include <unordered_map>
#include <map>
#include <algorithm>    // std::sort
#include <numeric>
#include <utility>

#include <stack>
#include <memory.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <thread>
#include <mutex>

#include "c_filter_fq.hpp"


#ifdef __linux__
#define __P__  return 0;   //__
#else
#define __P__  system("pause");return 0;   //__
#define popen(fp, fr) _popen((fp),(fr))
#define pclose(fp) _pclose(fp)
#define sleep(i) Sleep(1000*(i))
#endif
using namespace std;


#define DEL_ARR_MEM(P) if(NULL != (P)){delete [] (P); (P) = NULL;}



#if 1 

// begin static initialize area
uint64_t c_filter_fq::table_crc[sz_crc];

const unordered_map<char, char> c_filter_fq::dic_ATGC { { 'G', 'C' },{ 'A','T' },{ 'T','A' },{ 'C','G' },{'N','N'} };

int c_filter_fq::derepmin = 100;
int c_filter_fq::derep = 14; 
int c_filter_fq::lc_threshold = 7; 
string c_filter_fq::lc_method = string("dust"); 
string c_filter_fq::out_bad = string("null"); 
// end static initialize area


// cpp_ start 
c_filter_fq::c_filter_fq(const string &fn_config)
{
    read_config(fn_config);
    generate_crc_table();
}

void c_filter_fq::read_config(const string & fn_config)
{
/*  
perl $t/prinseq-lite.pl -derep 14 -derep_min 100 -lc_method dust -lc_threshold 7 -out_bad null -fastq $t/18B0000399-1-11.umhg19.fq -log $t/18B0000399-1-11.umhg19.fq.clean.log -out_good $t/18B0000399-1-11.umhg19.fq.clean 
*/

    ifstream if_config(fn_config.c_str()); assert(if_config.is_open()); 
    string e_str; 

    auto trim_string = [](std::string const &s)
    {
        if (s.empty()) 
        {
            return s;
        }

        auto loc_s = s.find_first_not_of(" ");
        auto loc_e = s.find_last_not_of(" ") + 1;
        return s.substr(loc_s, loc_e); 
    };


    unordered_map<string, string> map_param_k_v; 


    while(std::getline(if_config, e_str))
    {
        int cnt_eq_symbol = 0; 
        int loc_eq_symbol = 0; 
        int loc_p = 0; 
        e_str = trim_string(e_str);
        if (e_str[0] == '#' || e_str.size() <= 1) 
        { continue; }

        for(auto &e_ : e_str)
        {
            if(e_ == '=')
            {
                cnt_eq_symbol++; 
                loc_eq_symbol = loc_p; 
            }
            loc_p++; 
        }

        if (1 == cnt_eq_symbol)
        {
            //cout << e_str << " : "<<  loc_eq_symbol << endl; 
            string left_exp = e_str.substr(0, loc_eq_symbol); 
            string right_exp = e_str.substr(loc_eq_symbol+1); 

            auto left_exp_ = trim_string(left_exp); 
            auto right_exp_ = trim_string(right_exp); 

            assert(left_exp_.size() > 0); 
            assert(right_exp_.size() > 0); 

            map_param_k_v[left_exp_] = right_exp_; 
        }
        else
        {
            std::cerr << "- please make sure your filter.config has format [ key = value ] " << endl; 
            assert(1 == cnt_eq_symbol); 
        }
    }

    if_config.close(); 

#if 0 
    for(auto e: map_param_k_v)
    {
        cout << e.first << ":" << e.second << endl; 
    }
#endif


    string lc_method = map_param_k_v["lc_method"]; 
    auto len_lc_method = lc_method.size(); 
    assert(lc_method[0] = '"'); 
    assert(lc_method[len_lc_method-1] = '"'); 

    string out_bad = map_param_k_v["out_bad"]; 
    auto len_out_bad = out_bad.size(); 
    assert(out_bad[0] = '"'); 
    assert(out_bad[len_out_bad-1] = '"'); 

    // truely set the static var
    c_filter_fq::derepmin = atoi(map_param_k_v["derepmin"].c_str());
    c_filter_fq::derep = atoi(map_param_k_v["derep"].c_str()); 
    c_filter_fq::lc_threshold = atoi(map_param_k_v["lc_threshold"].c_str()); 

    c_filter_fq::lc_method = lc_method.substr(1, len_lc_method-2); 
    c_filter_fq::out_bad = out_bad.substr(1, len_out_bad-2); 
}


string c_filter_fq::run_cmd(const string& cmd){
	FILE *pf = popen(cmd.c_str(), "r");
	const int TO_READ_SZ = 1024;
	const char end_c = '\n'; 
	string res = string(TO_READ_SZ + 1, end_c); 

	if ( 0 != fread((void*)(res.data()),TO_READ_SZ, 1, pf))
	{
		printf( "- cannot run system cmd %s\n", cmd.c_str() ); 
		pclose(pf);
		assert(0==1);
		return string("NULL"); 
	};
	pclose(pf);
	res.erase(res.find_last_not_of(" \n\r\t\0") + 1);
	return res;
}

int c_filter_fq::map_md5all_exist_k0_k1(uint64_t k0, int k1)
{
    if (-1 == k1)
    {
        if (md5all.find(k0) != md5all.end())
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else if (md5all.find(k0) != md5all.end())
    {
        if (md5all[k0].find(k1) != md5all[k0].end())
        {
            return 1;
        }
    }
    return 0;
};

void c_filter_fq::generate_crc_table()
{
    const uint64_t poly = 0xC96C5795D7870F42;
    for (int i = 0; i<c_filter_fq::sz_crc; ++i)
    {
        uint64_t crc = i;

        for (int j = 0; j < 8; ++j)
        {
            // is current coefficient set?
            if (crc & 1)
            {
                // yes, then assume it gets zero'd (by implied x^64 coefficient of dividend)
                crc >>= 1;

                // and add rest of the divisor
                crc ^= poly;
            }
            else
            {
                // no? then move to next coefficient
                crc >>= 1;
            }
        }

        c_filter_fq::table_crc[i] = crc;
    }
}

uint64_t c_filter_fq::calculate_crc(const string& stream)
{

    uint64_t crc = 0;
    auto n = stream.size();
    for (int i = 0; i<n; ++i)
    {
        unsigned char index = (unsigned char)(stream[i] ^ crc);
        uint64_t lookup = c_filter_fq::table_crc[index];

        crc >>= 8;
        crc ^= lookup;
    }

    return crc;
}

int c_filter_fq::filter_out_e(vector<string> & v_s)
{
    // 0, not filter out; 1, filter out
    int ret_filter_out_code = 0;
    const int WINDOWSIZE = 64;
    const int WINDOWSTEP = 32;
    const float POINTFIVE = 0.5f;
    const float COMPLVAL = 7.0f;

    int good = 1;


    auto &seq = v_s[1];
    auto &qual = v_s[3];

    std::transform(seq.begin(), seq.end(), seq.begin(), ::toupper);
    auto &seqn = seq;

#if 0
    if (seqn == "ATGATAACCATCAAACATCCACAAAATTATATAAAACAAAAATACAGGAC")
    {
        int tt = 99; 
    }
#endif 

    auto length = seqn.size();
    int rest = 0; 
    int steps = 0; 

    if(length <= WINDOWSIZE) {
        rest = length;
        steps = 0;
    } 
    else
    {
        steps = (int)((length - WINDOWSIZE) * 1.0f / WINDOWSTEP) + 1;
        rest = length - steps * WINDOWSTEP;
		if( rest > WINDOWSTEP )
		{}
		else 
        {
            rest +=  WINDOWSTEP;  
            steps--; 
        }
    }

    auto num = WINDOWSIZE - 2;
    auto bynum = 1.0f / num;
    num--;
    auto mean = 0.0f;

    // cal "dust"
    float dustscore = 0.0f;
    vector<float> v_vals{};

    // 1
    for (int i = 0; i < steps; i++) 
    {
        auto str = seqn.substr((i * WINDOWSTEP), WINDOWSIZE);
        //%counts = ();
        unordered_map<string, int> counts;
        for (int i = 0; i < 62; i++) {
            counts[str.substr(i, 3)]++;
        }

        dustscore = 0;
        for (auto &e : counts)
        {
            auto &s_ = e.second;
            dustscore += (s_ * (s_ - 1) * POINTFIVE);
        }

        v_vals.push_back(dustscore * bynum);
    }

    // 2
    if (rest > 5)
    {
        auto str = seqn.substr((steps * WINDOWSTEP), rest);
        unordered_map<string, int> counts;
        num = rest - 2;
        for (int i = 0; i < num; i++) {
            counts[str.substr(i, 3)]++;
        }

        dustscore = 0;
        for (auto &e : counts)
        {
            auto &s_ = e.second;
            dustscore += (s_ * (s_ - 1) * POINTFIVE);
        }

        auto last_val = ((dustscore / (num - 1)) * ((WINDOWSIZE - 2) / (float)num));
        v_vals.push_back(last_val);
    }

    auto mean_ = accumulate(v_vals.begin(), v_vals.end(), 0.0) / v_vals.size();

    if ((int)(mean_ * 100 / 31) > COMPLVAL) 
    {
        ret_filter_out_code = 1;
    }

    if (0 == ret_filter_out_code)
    {
        auto crc_val = calculate_crc(seqn); 
        auto &md5 = crc_val;
        auto flag_md_exist = map_md5all_exist_k0_k1(md5, -1);

        if (!flag_md_exist)
        {
            md5all[md5] = { {0 , 0}, {3, 0} };
        }

        if (flag_md_exist)
        {
            auto& cnt_md5_k_0 = md5all[md5][0];
            cnt_md5_k_0++;
            if (c_filter_fq::derepmin <= cnt_md5_k_0 + 1)
            {
                ret_filter_out_code = 2;
            }
        }

        if (0 == ret_filter_out_code)
        {
            string seqn_r = string(seqn);
            std::reverse(seqn_r.begin(), seqn_r.end());

            for (auto& e : seqn_r)
            {
                e = c_filter_fq::dic_ATGC.at(e);               
            }

            auto md5r = calculate_crc(seqn_r);
            if (map_md5all_exist_k0_k1(md5r, -1))
            {
                auto& cnt_md5r_k_3 = md5all[md5r][3];
                cnt_md5r_k_3++;
                if (c_filter_fq::derepmin <= cnt_md5r_k_3 + 1)
                {
                    ret_filter_out_code = 3;
                }
            }
        }
    }

    return ret_filter_out_code;
}

void c_filter_fq::p_s_2_file(vector<string> & v_str, ofstream & of_) 
{
    v_str[2] = string(v_str[0]); 
    v_str[2][0] = '+';
    for (auto &e : v_str) { of_ << e << endl; }
};
// cpp_ end 

#endif 

// string to int , float and others 
#if 1
    auto str2int =[](string str) {
        stringstream ss;
        ss << str;
        int i;
        ss >> i;
        return i;
    };

    auto t = str2int("33"); 
    cout << t+1  << endl; 

#endif 

# member static const float, must constexpr 
        static constexpr float N_num_rate_threshold = 0.06f; 



#if 0
char buf[1024]; 
    sprintf(buf, 
            "%d\n"
            "%d",
            44,55); 
cout << string(buf); 
#endif 


#if 1
    uint64_t t = 0; 
    uint64_t t1 = 100; 
    uint64_t t2 = 25574639; 
    t += t1*t2; 
    printf("%lu\n", t); 
#endif 
// has pair in vector and for loop it 
#if 1
        unordered_map<int , pair<int, int>>  m
        {
                {0, make_pair(2,4)},
                {1, make_pair(1,3)},
                {2, make_pair(0,6)},
                {3, make_pair(2,1)},
        };

        vector <pair<int,int>> v ;

        for (auto &e : m)
        {
                //cout <<e.first << ":";
                auto &ee = e.second;
//cout <<ee.first <<" " <<ee.second << endl;
                        v.push_back(ee);
        }

#endif 
            auto k_ = string{ v_[i + 0],v_[i + 1],v_[i + 2],v_[i + 3] };

// member var cannot be caught by lambda 
    auto exists_m_sym_k = [&map_sym_val = map_sym_val](char k)
    {
        return  map_sym_val.find(k) != map_sym_val.end();
    };



// a thought works tw home work  20191103
//cpp_ add 

#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <assert.h>

#include <vector>
#include <unordered_map>



#include "line_parser.hpp"
using namespace std; 

bool line_parser::pre_c_in_vector(vector<char>& v_, char pre_c)
{
    bool flag_in = false; 
    for(auto ev: v_)
    {
        if (ev == pre_c)
        {
            flag_in = true; 
            break;
        }
    }
    return flag_in;  
}

void line_parser::say_line_ans()
{
    if (type_line_ans == VALID_QUESTION)
    {
        cout << line_ans << endl;
    }
    else if (type_line_ans == ERROR_ROMAN_SERIALS || type_line_ans == ERROR_LINE)
    {
        cout << "I have no idea what you are talking about" << endl;
    }
}

int line_parser::v_roman2sum(vector<char>& v_sym)
{
    auto len = v_sym.size();
    int sum = 0;
    int i = 0;
    for (i = 0; i<len - 1; i++)
    {
        int pre = map_sym_val[v_sym[i]];
        int next = map_sym_val[v_sym[i + 1]];
        if (pre < next)
        {
            sum += next - pre;
            i++;
        }
        else
        {
            sum += pre;
        }

    }

    if (i == len - 1)
    {
        int pre = map_sym_val[v_sym[i]];
        sum += pre;
    }

    return sum;
}

float line_parser::cal_units(vector<char>& v_sym, int value)
{
    auto sum = v_roman2sum(v_sym);
    return value * 1.0f / sum;
}

bool line_parser::valid_roman_serial(vector<char>& v_roman)
{
    auto exists_m_repeat_k = [&map_repeat_pat = map_repeat_pat](string k)
    {
        return  map_repeat_pat.find(k) != map_repeat_pat.end();
    };

    auto exists_m_substract_k = [&map_strsym_flag = map_strsym_flag](string k)
    {
        return  map_strsym_flag.find(k) != map_strsym_flag.end();
    };


    bool ret_code = true;
    const int sz = 4;
    auto len = v_roman.size();
    auto &v_ = v_roman;
    int flag_repeat_overflow = 0;
    if (len < sz)
    {
        flag_repeat_overflow = 0;
    }
    else
    {
        for (int i = 0; i < len - sz + 1; i += 1)
        {
            auto k_ = string{ v_[i + 0],v_[i + 1],v_[i + 2],v_[i + 3] };
            //cout << k_ << endl; 
            if (exists_m_repeat_k(k_))
            {
                flag_repeat_overflow = 1;
                //cout << "- met repeat pat " << k_ << endl; 
                break;
            }
        }
    }

    //cout << flag_repeat_overflow << endl;

    int i = 0;
    int flag_substract_error = 0;
    for (i = 0; i<len - 1; i++)
    {
        char pre_c = v_roman[i + 0];
        char next_c = v_roman[i + 1];

        int pre = map_sym_val[pre_c];
        int next = map_sym_val[next_c];


        if (pre < next)
        {
            //sum += next - pre; 
            if ( pre_c_in_vector(vec_cannot_be_sub_sym, pre_c) )
            {
                flag_substract_error = 1;
                //cout << pre_c << " cannot be substract" << endl; 
                break;
            }

            auto k_ = string{ pre_c, next_c };

            if (exists_m_substract_k(k_))
            {
                // ok 
            }
            else
            {
                if ( pre_c_in_vector(vec_must_be_sub_sym, pre_c) )
                {
                    flag_substract_error = 1;
                    //cout << pre_c << ":" << next_c << endl; 
                    break;
                }
                i++;
            }

        }
    }

    //cout << "- flag_substract_error : " << flag_substract_error << endl; 

    if (flag_repeat_overflow == 0 && flag_substract_error == 0)
    {
        ret_code = true;
    }
    else
    {
        ret_code = false;
    }

    return ret_code;
}

e_line_type line_parser::line_proc(string& e_line)
{
    e_line_type type = line_type(e_line);
    vector <char> v_sym{};
    string e_unit = "NULL";
    line_ans = "";
    type_line_ans = type;
    switch (type)
    {
    case STR2SYM:
    {
        map_str_sym[v_words[0]] = v_words[v_words.size() - 1][0];
        break;
    }
    case CAL_UNITS:
    {
        int cnt = 0;

        for (auto e : v_words)
        {
            if (e == "is")
            {
                break;
            }
            if (map_str_sym.find(e) != map_str_sym.end())
            {
                v_sym.push_back(map_str_sym[e]);
            }
            else
            {
                e_unit = e;
            }
            cnt++;
        }

        auto str_value = v_words[cnt + 1];
        int flag_num = 1;
        for (auto e_c : str_value) { if (!isdigit(e_c)) { flag_num = 0; break; } }

        if (0 == flag_num)
        {
            type = ERROR_LINE;
            type_line_ans = ERROR_LINE;
            break;
        }

        auto value = atoi(str_value.c_str());
        bool flag_valid_roman_serial = valid_roman_serial(v_sym);

        if (!flag_valid_roman_serial)
        {
            type_line_ans = ERROR_ROMAN_SERIALS;
            break;
        }
        auto unit_value = cal_units(v_sym, value);
        map_units_val[e_unit] = unit_value;
        //cout << e_unit << "=>" <<  unit_value<< endl;  
        break;
    }
    case VALID_QUESTION:
    {
        vector<string> v_question{};

        int cnt = 0;
        for (auto e : v_words)
        {
            if (e == "is")
            {
                break;
            }
            cnt++;
        }

        for (int i = cnt + 1; i < v_words.size() - 1; i++)
        {
            auto &e_v = v_words[i];
            //cout << e_v << endl; 
            if (map_str_sym.find(e_v) != map_str_sym.end())
            {
                v_sym.push_back(map_str_sym[e_v]);
                v_question.push_back(e_v);
            }
            else if (map_units_val.find(e_v) != map_units_val.end())
            {
                e_unit = e_v;
                v_question.push_back(e_unit);
            }

        }

        bool flag_valid_roman_serial = valid_roman_serial(v_sym);

        if (!flag_valid_roman_serial)
        {
            type_line_ans = ERROR_ROMAN_SERIALS;
            break;
        }

        auto v_sym_num = v_roman2sum(v_sym);
        int  ret_value = (int)(map_units_val[e_unit] * v_sym_num);

        string str_tail = "Credits";
        if (e_unit == "NULL")
        {
            ret_value = 1 * v_sym_num;
            str_tail = "";
        }

        //cout << ret_value << endl;

        for (auto e_v_q : v_question)
        {
            //cout << e_v_q << endl; 
            line_ans += e_v_q + " ";
        }
		ostringstream ss;
		ss << ret_value;
		line_ans += "is " + ss.str();

        if (str_tail != "")
        {
            line_ans += string(" ") + "Credits";
        }
        //cout <<"___" <<  line_ans << "___" << endl; 
        break;
    }
    case  ERROR_LINE:
    {
        type_line_ans = ERROR_LINE;
        break;
    }
    default:
    {
        type_line_ans = ERROR_LINE;
        break;
    }
    };

    return type_line_ans;
}

line_parser::line_parser()
{
    map_sym_val =
    {
        { 'I',   1 },
        { 'V',   5 },
        { 'X',   10 },
        { 'L',   50 },
        { 'C',   100 },
        { 'D',   500 },
        { 'M',   1000 },
    };

    map_repeat_pat =
    {
        { "IIII",0 },
        { "CCCC",0 },
        { "XXXX",0 },
        { "MMMM",0 },
    };

    map_strsym_flag =
    {
        { "IV", 1 },
        { "IX", 1 },
        { "XL", 1 },
        { "XC", 1 },
        { "CD", 1 },
        { "CM", 1 },
    };

    vec_must_be_sub_sym = {'I','X','C'}; 
    vec_cannot_be_sub_sym = {'V','L','D'}; 
}

vector<string> line_parser::split_str_2_vec(const string & str, const char & delimiter, const int & retainNum, int flag_push_tail_str)
{
    //std::vector<std::string>   vec_ret{};
    auto &vec_ret = v_words;
    v_words = {};
    vec_ret.reserve(16);

    std::stringstream  data(str);

    std::string line;
    if (retainNum == -1)
    {
        if (delimiter == ' ')
        {
            while (std::getline(data, line, delimiter)) // assume
            {
                // Note: if multiple delimitor in the source string,
                //           you may see many empty item in vector
                if (line == "") continue;
                vec_ret.push_back(line);
            }
            return vec_ret;
        }
        while (std::getline(data, line, delimiter))     // assume
        {
            // Note: if multiple delimitor in the source string,
            //       you may see many empty item in vector
            vec_ret.push_back(line);
        }
    }
    else
    {
        if (delimiter == ' ')
        {
            int cnt = 0;
            while (std::getline(data, line, delimiter)) // assume
            {
                if (cnt >= retainNum) break;
                if (line == "") continue;
                vec_ret.push_back(line);
                cnt++;
            }
            return vec_ret;
        }
        int cnt = 0;
        while (cnt < retainNum && std::getline(data, line, delimiter))     // assume
        {
            //if (cnt >= retainNum) break;
            vec_ret.push_back(line);
            cnt++;
        }
    }

    if (flag_push_tail_str)
    {
        std::getline(data, line, '\a');
        vec_ret.push_back(line);
    }


    return vec_ret;
}

e_line_type line_parser::line_type(string &e_line)
{
    auto exists_m_sym_k = [&map_sym_val = map_sym_val](char k)
    {
        return  map_sym_val.find(k) != map_sym_val.end();
    };

    split_str_2_vec(e_line);

    if (3 == v_words.size()
        && v_words[1] == "is"
        && 1 == v_words[2].size()
        && exists_m_sym_k(v_words[2][0]))
    {
        return STR2SYM;
    }
    else if (v_words.size() >= 5
        && v_words[v_words.size() - 1] == "Credits"
        && isdigit(v_words[v_words.size() - 2][0]))
    {
        return CAL_UNITS;
    }
    else if (v_words.size() >= 5
        && v_words[0] == "how"
        && (v_words[1] == "many" || v_words[1] == "much")
        && (v_words[2] == "is" || v_words[2] == "Credits")
        && v_words[v_words.size() - 1] == "?"
        )
    {
        return VALID_QUESTION;
    }
    else
    {
        return ERROR_LINE;
    }
}
//cpp_ end

// is_same decltype
    auto arr = new auto(33); 
    cout << std::is_same<decltype(arr), int *>::value << endl; 
// using usage 
    using vi = vector<int>;
    vi id{ 9 };

#if 1
template <typename... T>
void fun(T... id_t)
{
    cout << sizeof...(id_t) << endl; 
}

#endif 

// st__ main_
int main(int argc, char **argv)
{
#if 1
    fun(1, "2");

#endif 

} 

// lvalue rvalue 
void reference(std::string& str) {
	std::cout << "lvalue" << std::endl;
}
void reference(std::string&& str) {
	std::cout << "rvalue" << std::endl;
}


string && rv2 = string("a") + "bbb";  // rvalue
rv2 = "new"; // lvalue 
// to move why fast 
vector_a.push(std::move(xxxx)); 

v.shrink_to_fit();   // return memory to system 

// std::array 

#if 1

    constexpr int LEN = 4; 
    std::array<int, LEN> arr = { 1,2,3,4 }; 

    auto parr = arr.data(); 
    auto parr_2 = &arr[0]; 

    cout << arr.size() << endl; 

    cout << parr[2] << endl; 
    cout << parr_2[2] << endl;
    assert(parr[2] == parr_2[2]);

#endif 



// c++ raw string 


string r0 = R"(73724823478234723*+-//\\\\\\\\\\\)"; 
 auto x = std::to_string(4) + "abc"; 
        cout << x << endl; 

   cout << 100 + std::stoi("445") << endl;;
 cout << 100 + std::stof("445.001") << endl;;


- file map to memory and write back automatically  mmap()
https://zhuanlan.zhihu.com/p/90673842
-

###### python opencv cv2 notebook open image and show 
# pip install opencv-python 
from __future__ import print_function
from matplotlib import pyplot as plt
import numpy as np
import cv2

fn = "car.jpg"
img = cv2.imread(fn)


cv2.imshow("detected lines", img)

cv2.waitKey(0)

show_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) 




# plt.imshow(show_img)
# plt.show()

img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) 



# show a simple , self create image 	
from __future__ import print_function
from matplotlib import pyplot as plt
import numpy as np
import cv2

id_m = np.array([[[111,211,113],[3,4,5]], [[11,21,31],[32,42,52]]])
print(id_m.shape)  # print(id_m.shape)  

id_m[:,:,[0,2]] = 0

print (id_m)

plt.imshow(id_m)
plt.show()

// disable assertion 

c_flag = -O3 -DNDEBUG -Wno-format -fpermissive

*********************
run_test.PL
*********************
#!perl

#######################################################
=pod
written by Jidor Tang at 2019-07-11

synopsis:
    to run test cases for cpp project `filter_fq`
usage:
    fill the `global var` with your testcases, and run
    `perl run_test.PL`, you may use comments amid.
=cut
#######################################################

##################
### global var ###
##################

my @arr_fn_fq = qw(
./data/l_1k.fq
#./data/V30001000_L01_2.fq
);
my @td_pool = ();
my $td_idx :shared = -1;
my @run_logs_all :shared = ();
##################

use strict;
use feature qw(say);
use threads;
use threads::shared;

&main();

sub main()
{
        qx{make};

        for my $e_fn_fq (@arr_fn_fq)
    {
        push @td_pool, threads->create
        (
            \&run_each_fq, $e_fn_fq   #&run_each_fq($e_fn_fq)
        );
    }

    for my $e_td (@td_pool)
    {
        $e_td->join();
    }
    say "\n\n\n- summary\n-----------------";
    say join "\n", sort @run_logs_all;
}

sub say_time_diff_t0_t1($cmd,  $t0,$t1, $td_idx_)
{
        my ($cmd , $t0,$t1, $td_idx_) = ($_[0], $_[1], $_[2], $_[3]);
        my $d = $t1 - $t0;
        my @cmd_arr = split m/\s+/, $cmd;
        my $loc_e = 2;
        if (! -f $cmd_arr[$loc_e])
        {
                $loc_e = 1;
        }
        my $cmd_short = join " " , (split m/\s+/, $cmd)[0..$loc_e];
        return "- thread id: $td_idx_, [ $cmd_short ], spend time $d seconds";
}

sub run_each_fq($fn_fq)
{
    my $fn_fq = shift;
    my $ff="perl $ENV{perl_p}/ff.PL";

    $fn_fq =~ s/^\s+//; chomp($fn_fq);
    #say $fn_fq;
    if ($fn_fq =~ m/^\#/)
    {
        return 0;
    }

    $td_idx++;

    my $td_idx_ = $td_idx;
        my $barcode = "AGCTAG";

    my $cmd_pl = qq{sh old_pl/run_pl.sh $fn_fq 2>&1 | grep -A2 -P '^\#Total'| $ff 0 1};
    my $cmd_cpp = qq{./mainapp.exe $fn_fq $barcode 2>&1 | grep -A2 -P '^\#Total'| $ff 0 1};

    my $run_log_pl:shared ; my  $cnt_pl:shared;
    my $run_log_cpp: shared; my $cnt_cpp :shared;

    my $td_pl = threads->create(
        \&run_each_shell,  $cmd_pl , $td_idx_,  \$run_log_pl, \$cnt_pl
    );
    my $td_cpp = threads->create(
        \&run_each_shell,  $cmd_cpp , $td_idx_,  \$run_log_cpp, \$cnt_cpp
    );

    $td_cpp->join(); my $e_run_log_cpp = $run_log_cpp.  ", total:keep is $cnt_cpp";
        say $e_run_log_cpp ;

    $td_pl->join(); my $e_run_log_pl = $run_log_pl. ", total:keep is $cnt_pl";
    say $e_run_log_pl ;

    push @run_logs_all , ($e_run_log_pl, $e_run_log_cpp);

    if ($cnt_pl ne $cnt_cpp)
    {
        say "- error, $td_idx_, [$cmd_pl] vs [$cmd_cpp] ";
    }



    my $_1=`basename $fn_fq`; chomp($_1);

    my $fn_out_cpp = qq{./data/$_1.clean.fastq};
    my $fn_out_pl = qq{./old_pl/$_1.clean.fastq};

    if (`cksum $fn_out_cpp| $ff 0 1`  ne `cksum $fn_out_pl | $ff 0 1`)
    {
        say qq{vimdiff $fn_out_cpp $fn_out_pl};
        #system(qq{vimdiff ./data/$_1.clean.fastq ./old_pl/$_1.clean.fastq});
    }
}

sub run_each_shell($cmd_shell, $td_idx_,\$,\$)
{
    my $cmd_shell = shift;
    my $td_idx_ = shift;
    my $run_log_ref_ = shift;
    my $cnt_ref_ = shift;

    my $t0 = time();
    #my $cmd_cpp = qq{./mainapp.exe $fn_fq};
    my @cmd_out_ = qx{$cmd_shell};
    my $t1 = time();

    my $run_log = &say_time_diff_t0_t1($cmd_shell, $t0, $t1,$td_idx_);

    chomp(@cmd_out_);
    $$run_log_ref_ = $run_log;
        my $cnt_bad_seq = $cmd_out_[1];
        $cnt_bad_seq =~ s/\D/:/g;
    $$cnt_ref_ = $cnt_bad_seq;

    return ($run_log, $cnt_bad_seq);
}

EOF


 std::getline(cin, e_s, '\n');

 std::stringstream data(input_string);

 while(getline(data, e_s, ' '))
{

}



#if 1
// permutation by c++ , jd 20200315
vector<string> perm(string S)
{
    if (S.size() == 1)
    {
        return vector<string> {S};
    }
    else if (S.size() == 2)
    {
        return vector<string> {string{ S[0],S[1] }, string{ S[1], S[0] }};
    }
    else
    {
        auto vector_S_n_1 = perm(S.substr(1));
        vector<string> to_save = {};

        for (auto e_s : vector_S_n_1)
        {
            auto len = e_s.size();
            for (int i = 0; i < len + 1; i++)
            {
                auto s0_e_s = string{ S[0] } +e_s;
                swap(s0_e_s[0], s0_e_s[i]);
                to_save.push_back(s0_e_s);
            }
        }
        return to_save;
    }
}

#endif 


sort(v_i.begin(), v_i.end(), [](int a,int b) {return a >= b; });


// sort by bubble , c++, 
vector <vector<int>> v_v{
	{ 7,0 },
	{ 4,4 },
	{ 7,1 },
	{ 5,0 },
	{ 6,1 },
	{ 5,2 }
};


	auto len = v_v.size(); 
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = i; j < len-1; j++)
		{
			auto &a = v_v[j]; 
			auto &b = v_v[j + 1];
			if (a[0] * 8 - a[1] < b[0] * 8 - b[1])
			//if(a[0] < b[0])
			{
				swap(a, b);
			}
		}
	}

/*
7 0
7 1
6 1
5 0
5 2
4 4
*/
sort(v_v.begin(), v_v.end(), [](vector<int>& a, vector<int>& b) {return a[0]*8 - a[1] > b[0]*8 - b[1]; });

sort(v_v.begin(), v_v.end(), [](vector<int> a, vector<int> b) {return a[0]*8 - a[1] > b[0]*8 - b[1]; });


// a, b, c, d, e
// 0, 1, 2, 3, 4
// if d =2, idx=3, 
//ans : 
// 0 3 1 2 4  //https://zhuanlan.zhihu.com/p/113431227
void left_shift_idx_by_d(int d, int idx)
{
	printf("d:%d, idx:%d\n", d, idx);
	auto temp = v_v[idx];
	for (int i = idx-1; i >= idx - d; i--)
	{
		v_v[i + 1] = v_v[i];
	}
	v_v[idx - d] = temp;
}

#if 1
// include <deque>
    std::deque<vector<int>> dq{
        {1, 2},{ 3,4},{3,5},{5,4},{6,7}
};
    dq.push_back({ 33,33 });
    dq.push_front({0,0});

    int idx = 1;
    dq.erase(dq.begin() + idx, dq.begin() + idx + 2);

    dq.insert(dq.begin() + idx, { {11,11},{22,22} });

    for (auto e : dq)
    {
        for (auto e_ : e)
        {
            cout << e_ << " ";
        }
        cout << endl;
    }


#endif 


#if 1
// #include <list>
// c++ list usage, insert, pop
	list<int> id_l{ 1,2,4 }; 

	auto it_ = std::find(id_l.begin(), id_l.end(), 4);
	id_l.insert(it_, 3);

	id_l.push_back(5); //1 2 3 4 5
	for (auto e : id_l)
	{
		cout << e << endl; 
	}
	cout << endl; 
	int cnt = 0;

	// auto tt = id_l.begin() + 2; compile error 
	for (auto it = id_l.begin(); it != id_l.end(); it++)
	{

		if (cnt++ == 2)
		{
			assert(*it == 3);
			id_l.erase(it++);
			//cout << *it << endl;  //4
			break;
		}
	}



#endif 

#if 1
// sort list , vector 
    list<int> id_l{ 3,4,1 }; 
    id_l.sort([](int a, int b) {return a > b; });  // 1,3,4

    vector<int> id_v{3,4,1};
    std::sort(id_v.begin(), id_v.end(), [](int a, int b) {return a > b; });
    id_v.insert(id_v.begin() + 2, 55); //{1,3,55,4}
#endif 

#if 1
	// map will be ordered set, no repeated item
#if 1
    map<int, vector<int>> id_i_v{
        { 1,{ 2,3 } },
        { 4,{ 2,3 } },
        { 0,{ 2,3 } },
        { 4,{ 2,3 } },

    };

    for (auto e_m : id_i_v)
    {
        cout << e_m.first << ": ";
        for (auto e : e_m.second)
        {
            cout << e << " ";
        }
        cout << endl;
    }
// 0,1,4
#endif

#if 1
    // c++ set , order, no repeat  vs map
    set<int> id_set{ 1,3,3,0 };

    for (auto e : id_set)
    {
        cout << e << endl;  // 0,1,3
    }
#endif 

class A {
public:
    int x; 
    int y;
    A(int x, int y)
    {
        this->x = x + x; 
        this->y = y; 
        cout << x << endl;  // param it is param.x 
    }
};


// C++ enum class 
class E
{
public:
    enum class E_inner
    {
        E0,
        E1
    };

    E_inner id_E0;
    E_inner id_E1;

    E(E_inner e_)
    {
        id_E0 = e_;
        id_E1 = e_;
    }
};


#if 1
  
    E id_E(E::E_inner::E0);

#endif


bool CigarOperator::operator==(const CigarOperator & id_c1) const
{
    return this->id_SS == id_c1.id_SS;
}

class A
{
public:
    int x; 

    static const A id_A0; 

    static const A id_A1;

    static A create(int x)
    {
        A id_A; 
        id_A.x = x; 
        return id_A;
    };

};

const A A::id_A0 = create(22); 
const A A::id_A1 = create(222);


	auto cmd_get_bin_dir = string("readlink -f ") + string(argv[0]) + string(" | xargs dirname"); 
	auto folder_bin = c_strip_barcode::run_cmd(cmd_get_bin_dir.c_str());
	auto ret_code = chdir(folder_bin.c_str()); assert( ret_code == 0 ); 

	if ( string("strip_barcode_fq") != c_strip_barcode::run_cmd("basename `pwd`") )
	{
		std::cerr << "- please run :[ cd strip_barcode_fq ] firstly" << endl;
		assert(0==1); 
	}



	while (std::getline(if_, e_str))
	{
		auto v_idx = cnt_lines < e_line_sz ? cnt_lines : cnt_lines % e_line_sz;
		v_str[v_idx] = e_str;

		cnt_lines++;

		if (0 == cnt_lines % e_line_sz)
		{
			int flag_filter_out = id_c_strip.filter_e_barcode_out(v_str); 
			id_c_strip.stat_e_total_keep(flag_filter_out);

			if ( 0 == flag_filter_out )
			{
				id_c_strip.p_s_2_file(v_str, of_, len_barcode + 1); 
			}
		}
	} // end while ()


		sscanf(e_str.c_str(), "%s\t%d\t%d", buf_0, &buf_1, &buf_2);


# perl set var :
$Len ||=35;

string c_filter::get_root_path(int argc, char** argv)
{
    string abs_root = run_cmd( string("readlink -f  ")+  string(argv[0]) + " | xargs dirname" ); 
    return abs_root; 
}


