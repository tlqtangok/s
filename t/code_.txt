**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



///////////////////////
**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



//////////
// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

     
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();
     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    
   

    return -1; 

    //////////////////////////////////

void clear_img_corner(Mat & id_m){

    for (int i=0;i<id_m.rows/4;i++){
        for(int j=0;j<id_m.cols/3;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=255; 

            }
        }
    }

}

int _tmain(int argc, char** argv)
{


// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
  /*
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

    */ 
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();



     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    

    // clear_img_corner( id_mm ); 

     
     id_mm= id_mm.t();

   imshow("imshow", id_mm ); 
   waitKey(0);


    return -1; 

    //////////////////////////////////
imwrite("test.bmp", id_t); 

int _tmain(int argc, char** argv)
{

    Mat id_t = Mat::zeros(444,444, CV_8UC(1)); 


    int x = 999;
    char buf[111]={0};
    sprintf_s(buf, "%d", x);

    

    putText( id_t, string(buf), Point(id_t.cols/2,id_t.rows/2), 1, 1, Scalar(255) ); 


   // imshow( "id_t", id_t); 

   // imwrite("test.bmp", id_t); 

    int id = 9; 
    id_map[id] = id_t ; 
    id_map[id+1] = id_t; 
    for ( auto tt : id_map ){
    tt.first; 
    auto id_x = tt.second;

    imshow( "id_x", id_x);
    cv::waitKey(0);
    
    }


    



    return -1; 

    //////////////////////////////////
    Mat id_m = imread( "x:\\test_small_50.bmp");
    Mat id_dst_m; 
resize( id_m, id_dst_m, Size(id_m.cols, id_m.rows*(1+3.5/100)), 0, 0, INTER_LINEAR);

Mat id_mm(id_m, Range(1,id_m.rows-20), Range::all()); 
uchar* from_mat_2_pdata(uchar* pData, Mat& id_mt){

    int i=0;
    int j=0;

    int rows_ = id_mt.rows; 
    int cols_ = id_mt.cols;
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            pData[cnt++] = t[0]; 
        }
    }


    return pData;

}

Mat from_pdata_2_mat(uchar* pData, int rows_, int cols_){
    Mat id_mt(rows_, cols_, CV_8UC(1));
    int i=0; int j=0 ; 
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            t[0] = pData[cnt++]; 
        }
    }

    return id_mt;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  int to_cut_bottom_len){

    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);


    Mat id_mm(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_bottom_len)); 
    Mat id_dst_m; 
    resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, INTER_LINEAR);

    from_mat_2_pdata(pData, id_dst_m); 
    return pData;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  bool is_cut_cols_, int to_cut_len){


    double Time = (double)cvGetTickCount();
// ?㷨????





    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);
    Mat id_mm; 
    Mat id_dst_m; 
/*
    enum
{
    INTER_NEAREST=CV_INTER_NN, //!< nearest neighbor interpolation
    INTER_LINEAR=CV_INTER_LINEAR, //!< bilinear interpolation
    INTER_CUBIC=CV_INTER_CUBIC, //!< bicubic interpolation
    INTER_AREA=CV_INTER_AREA, //!< area-based (or super) interpolation
    INTER_LANCZOS4=CV_INTER_LANCZOS4, //!< Lanczos interpolation over 8x8 neighborhood
    INTER_MAX=7,
    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP
};
*/

    
    int interop_way = INTER_NEAREST;
    if ( is_cut_cols_ ){
        
        id_mm = Mat(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_len)); 
         resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }
    else {
        id_mm = Mat(id_mt, Range(0,id_mt.rows-to_cut_len), Range(0,id_mt.cols)); 
        resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }

   
    from_mat_2_pdata(pData, id_dst_m); 

    Time = (double)cvGetTickCount() - Time ;

    printf( "run time = %gms\n", Time /(cvGetTickFrequency()*1000) );//????
    return pData;
}



Mat  read_bmp_and_T(string str_fn){
    Mat id_m = imread(str_fn); 
    return id_m.t(); 
}


#include <thread>
#include <mutex>
#include <iostream>
using namespace std;
mutex g_mutex;
int g_count = 0;
int main()
{
	thread thr1([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 10;
			}
			});
	thread thr2([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 20;
			}
			});
	thr1.join();
	thr2.join();
	cout << g_count << endl;
}
 
*********************
test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
using namespace std;
void fun1(int n) //??ʼ?????캯??
{
	cout << "Thread " << n << " executing\n";
	n += 10;
	this_thread::sleep_for(chrono::milliseconds(10));
}
void fun2(int & n) //???????캯??
{
	cout << "Thread " << n << " executing\n";
	n += 20;
	this_thread::sleep_for(chrono::milliseconds(10));
}
int main()
{
	int n = 0;
	thread t1; //t1????һ??thread
	thread t2(fun1, n + 1); //????ֵ????
	t2.join();
	cout << "n=" << n << '\n';
	n = 10;
	thread t3(fun2, ref(n)); //????
	thread t4(move(t3)); //t4ִ??t3??t3????thread
	t4.join();
	cout << "n=" <<n << endl;
       	return 0;
}

*********************
compile_by_arm_g++.sh
*********************
ARM_GCC_ROOT=/home/cross/imx6qplus/gcc/gcc-linaro-arm-linux-gnueabihf-4.8-2014.04_linux
#arm-linux-gnueabihf  bin  lib  libexec  share
alias arm_gcc=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-gcc
alias arm_g++=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-g++

THIRD_PARTY_DIR=/home/cross/imx6qplus/third_libs_imx6qp
OPENCV_INC=${THIRD_PARTY_DIR}/include
LIB_DIR=${THIRD_PARTY_DIR}/lib
LIB_DIR_QT=/home/cross/imx6qplus/QT/lib
 NAME_OF_LIBS="-lopencv_calib3d -lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lopencv_nonfree -lopencv_objdetect -lopencv_photo -lopencv_stitching -lopencv_superres -lopencv_video -lopencv_videostab"
#export LD_LIBRARY_PATH=${LIB_DIR}:${LIB_DIR_QT}:$LD_LIBRARY_PATH

arm_g++ -std=c++11  -pthread -Wl,-no-as-needed test.cpp  -I${OPENCV_INC} -L${LIB_DIR_QT}  -L${LIB_DIR} 


EOF

//get cpu number
#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
#include<iostream>
#include<thread>
using namespace std;
int main()
{
        auto n = thread::hardware_concurrency();//??ȡcpu???ĸ???
        cout << n << endl;
        return 0;
}


*********************
/home/tanglq/t/test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
atomic_int num{0};

const int N = 100000;

void run()
{
	for (int i = 0; i < N; i++)
	{
		num++;
	}
}
int main()
{
	clock_t start = clock();
	thread t1(run);
	thread t2(run);
	t1.join();
	t2.join();
	clock_t end = clock();
	cout << "num=" << num << ",??ʱ " << end - start << " ms" << endl;
	return 0;
}

EOF


	auto fun = [](){
	cout << "lambda fun()\n"; 
	};  // must have a semicolon here 

	fun();

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
using namespace std;
atomic_int num{0};

const int N = 10000000;

void run()
{

	for (int i = 0; i < N; i++)
	{
		num++;
	}
}

int main()
{
// lambda + this_thread 
	thread th1([]() {
			//???̵߳ȴ?3??
			this_thread::sleep_for(chrono::seconds(3));
			//??cpuִ?????????е??߳?
			this_thread::yield();
			//?߳?id
			cout << this_thread::get_id() << endl;
			});

	th1.join();
	return 0;


}


   int a = 9; 
   int b = 88; 
   swap(a,b); 

*********************
/home/tanglq/t/test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
#include <atomic>
#include<cstdarg>
#include <Windows.h>
#include <stdio.h>
using namespace std;



using namespace std;




void thread01()
{
	for (int i = 0; i < 5; i++)
	{
		cout << "Thread 01 is working ??" << endl;
		Sleep(100);
	}
}
void thread02()
{
	for (int i = 0; i < 5; i++)
	{
		cout << "Thread 02 is working ??" << endl;
		Sleep(200);
	}
}
int main()
{
	thread task01(thread01);
	thread task02(thread02);
	task01.detach();
	task02.detach();
	for (int i = 0; i < 5; i++)
	{
		cout << "Main thread is working ??" << endl;
		Sleep(200);
	}
	return 0;
}


EOF

iplimage struct


void print_iplimage(IplImage* img){

    int rows = img->height;
    int cols = img->width; 
    int step = img->widthStep; 
    for ( int i = 0; i< rows; i++)
    {
        for ( int j = 0; j< cols; j++)
        {
            uchar t = CV_IMAGE_ELEM( img, uchar,  i, j ); 
            printf("%d ", t); 
        }
        cout << "\n"; 
    }
};


int _tmain(int argc, char** argv)
{

    int rows = 5;
    int cols = 5; 
    int step = cols; 

    auto id_m_header = cvCreateImageHeader(cvSize(cols, rows), 8, 1);   // mem 0 
    char *pdata_r0 = new char[ rows * step ];  // mem 2
    char *pdata = pdata_r0; 
    id_m_header->imageData = pdata; 
    delete [] pdata_r0;  // rel 2
    cvReleaseImageHeader( &id_m_header );  // rel 0 





    IplImage *img = cvCreateImage( cvSize(cols,rows), 8, 1 );  // mem 1

    rows = img->height;
    cols = img->width; 
    step = img->widthStep; 

    int id_row = 1; 
    int id_col = 1; 
    auto& t = (img->imageData[id_row * step + id_col]) ;
    t = 111; 

    uchar get_e_t = CV_IMAGE_ELEM(img, uchar , id_row, id_col); 
    print_iplimage( img ); 

   
    cvReleaseImage(&img); // rel 1

    __P__; // system("pause");
    return 0;
} // end main()






///////


void print_iplimage(IplImage* img){

    int rows = img->height;
    int cols = img->width; 
    int step = img->widthStep; 
    for ( int i = 0; i< rows; i++)
    {
        for ( int j = 0; j< cols; j++)
        {
            uchar t = CV_IMAGE_ELEM( img, uchar,  i, j ); 
            printf("%d ", t); 
        }
        cout << "\n"; 
    }
};


int _tmain(int argc, char** argv)
{
    int r = 40; 
    int c = 40;

    IplImage * id_mm = cvCreateImage( cvSize(c,r), 8, 1 ); 
    CV_IMAGE_ELEM( id_mm, uchar, id_mm->height/2, id_mm->width/2) = 0; 
    cvNamedWindow( "fileName");
    cvShowImage( "fileName", id_mm );
    cvSaveImage("filename.bmp",id_mm);
    cvWaitKey(1);

    IplImage* id_mmm = cvCloneImage( id_mm ); 
    cvReleaseImage( &id_mm ); 



    // only have id_mmm
    CvMat *subMat = cvCreateMat( id_mmm->height/2, id_mmm->width/2, CV_8UC1); 
    cvGetSubRect(id_mmm, subMat, cvRect(0, 0, id_mmm->height/2,id_mmm->width/2));
    cvReleaseMat( &subMat );

    cvReleaseImage( &id_mmm );


    // only get id_m
    CvMat* id_m = cvCreateMat(2, 4, CV_32FC1);  // mem 0 
    cvmSet( id_m, 1,1, 5.99f); 
    cvmGet( id_m, 1,1 ); 
    auto sz_id_m = cvGetSize( id_m ); sz_id_m.width; sz_id_m.height; 

    //cvZero( id_m );
    double t = cvmGet( id_m, 1 ,1); 
    printf("%f\n", t); 


    cvReleaseMat( &id_m ); // rel 0


    CvScalar id_rgb     = CV_RGB(255,255,255); 		// cv rgb 
    //cout << id_rgb.val[0] << endl; 


    __P__; // system("pause");
    return 0;
} // end main()






///////
// iplimage open image and show img 
void show_iplimg(IplImage *img){

    cvNamedWindow("tmp_win" ); 

    cvShowImage( "tmp_win", img);
    cvWaitKey();
    return;
};

int _tmain(int argc, char** argv)
{
    IplImage* pImg = cvLoadImage( "filename.bmp", 0);

    show_iplimg( pImg ); 

    __P__; // system("pause");
    return 0;
} // end main()


// multiple channel image read and write
    int rows = id_m->height;
    int cols = id_m->width; 
    int step = id_m->widthStep;
    int c = id_m->nChannels;
    for( int i=0;i<rows/2;i++){
        for( int j=0;j<cols/2;j++){

            for(int k=0;k<c;k++){
                auto& t = id_m->imageData[i*step + j*c + k];
                t = 0; 
            }

        }
    }
//////////// sigint SIGINT ///////////
// bld
//gcc test.c -o test.exe -l pthread
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#define true 1
void * One(void * no)
{
        while (true)
        {
                printf("NUAACS1\n");
                sleep(1);
        }
}
void * Two(void * no)
{
        while (true)
        {
                printf("NUAACS2\n");
                sleep(1);
        }
}
void Stop(int signo)
{
        printf("oops! stop!!!\n");
        _exit(0);
}
int main()
{
        int res;
        pthread_t A, B;
        signal(SIGINT, Stop);
        res = pthread_create(&A, NULL, One, NULL);
        res = pthread_create(&B, NULL, Two, NULL);
        res = pthread_join(A, NULL);
        res = pthread_join(B, NULL);
        return 0;
}

// cmd system buf 
// char len 
// sigint
int run_cmd(char* cmd, char *res){
        FILE *pf = popen(cmd, "r");
        const int TO_READ_SZ = 1023;
        if ( 0 != fread(res,TO_READ_SZ, 1, pf)){
                printf( "- cannot run system cmd %s\n", cmd ); 
                return -1; 
        } ;
        pclose(pf);
        return 0;
}
void stop_in_sig_int(){
        fclose(fp);
        printf( "\n- meet ctrl+c \n");
        _exit(0);

}
int main(int argc, char *argv[])
{  

        signal(SIGINT,stop_in_sig_int);

        int retval = -1;
        double cur_value;
        double high_value;
        cur_value = 0.0;
        high_value = 0.0;
        char buf[1024] = {0};
        run_cmd( "date \"+%Y%m%d_%H%M\" ", buf ); 
        printf( "%s", buf ); 

        char buf_fn[1024] ={0};
        sprintf( buf_fn, "temp_log_%s", buf); 
        buf_fn[strlen("temp_log_20170406_xxxx")] = '\0';
        fp = fopen(buf_fn, "a+");
        while (1)
        {
                retval =get_cpu_temperature("coretemp-isa-0000", &cur_value, &high_value);
                fprintf(fp, "cur_value=%f,high_value=%f\n",cur_value,high_value);
                printf( "cur_value=%f,high_value=%f\n",cur_value,high_value);
                sleep(5);
        }
        fclose( fp ); 
        return retval;
}

date --set="2017-06-08 14:51"
// set time and date by time STRING string 
// linux SIGALAM timer alarm usage 
// ////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
int sec;
const int BUF_TIME_MAX  = 256; 
char buf_time[BUF_TIME_MAX] = {0};

int run_cmd(char* cmd, char *res);

char* get_now(int flag_print=0){
        run_cmd( (char*)"date \"+%Y%m%d_%H%M : %S\" ", buf_time );
        if(flag_print){
                printf( "%s\n", buf_time);
        }
        return buf_time;
}
void sigroutine(int signo){
        get_now(1); 
        switch (signo){
                case SIGALRM:
                        printf("Catch a signal -- SIGALRM \n");
                        //                      signal(SIGALRM, sigroutine);
                        break;
                case SIGVTALRM:
                        printf("Catch a signal -- VT \n");
                        //      signal(SIGVTALRM, sigroutine);
                        break;
        }
        return;
}



void sigalrm_fn(int sig)
{
        static int cnt = 9; 
        cnt--;
        if(cnt){
                printf(" SIGALARM:%d, cnt:%d!\n", sig,cnt);
                alarm(1);
                return ;
        }
        //_exit(0);
        //clear alarm
        alarm(0);
        return;
}



int main()
{



           itimerval value, ovalue, value2; //(1)
           sec = 5;
           printf("process id is %d\n", getpid());
           signal(SIGALRM, sigroutine);
           signal(SIGVTALRM, sigroutine);
           int start_fire_time = 3; 
           int interval_time = 1; 
        // timer first fire from t0=0+10, then intervally fire at 10+4
        value.it_value.tv_sec = start_fire_time;
        value.it_value.tv_usec = 0;
        value.it_interval.tv_sec = interval_time;
        value.it_interval.tv_usec = 0;
        setitimer(ITIMER_REAL, &value, &ovalue); //(2)


        value2.it_value.tv_sec = 0;
        value2.it_value.tv_usec = 500000;
        value2.it_interval.tv_sec = 0;
        value2.it_interval.tv_usec = 500000;
        setitimer(ITIMER_VIRTUAL, &value2, &ovalue);

        //signal(SIGALRM, sigalrm_fn);
        //alarm(3);

        for(;;){
;
        }
}

int run_cmd(char* cmd, char *res){
        FILE *pf = popen(cmd, "r");
        const int TO_READ_SZ = 1023;
        if ( 0 != fread(res,TO_READ_SZ, 1, pf)){
                printf( "- cannot run system cmd %s\n", cmd ); 
                return -1; 
        } ;
        pclose(pf);
        return 0;
}


// ////////////////////////////////////////////////////
// windows pipe _popen() 
int run_cmd(char* cmd, char *res) {
	FILE *pf = _popen(cmd, "r");
	const int TO_READ_SZ = 1024;
	if (0 != fread(res, TO_READ_SZ, 1, pf)) {
		printf("- cannot run system cmd %s\n", cmd);
		return -1;
	};
	_pclose(pf);
	return 0;
}

int _tmain(int argc, char** argv)
{
    ofstream of("x:\\txt1.txt", ios::out); 
    of << "ABC123" << endl ; 
    of.close(); 


    ifstream if_("x:\\txt1.txt", ios::in); 

    int cnt = 9; 
    int x = 0; 


    string sb = ""; 
    const int ENTER_KEY = 10;
    while( -1 != (x = if_.get()) && x != ENTER_KEY ){
        sb += x; 
    }

    if_.close(); 

    cout << "---"<< sb << "---"<<endl;    // need chomp 
    __P__; // system("pause");
    return 0;
} // end main()

// to_string_() write_buf_2_file()
//#include <thread>
//#include <chrono>
//#include <atomic>
#ifdef _MSC_VER
  #include <Windows.h>
#endif
#include <cstdarg>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>
//#include <opencv2/opencv.hpp>
using namespace std; 
#define OF_W (ios::out|ios::trunc)
template<typename T>
string to_string_(T n){
	ostringstream ss; 
	ss << n ;
	return ss.str();
}
void write_buf_2_file(const string & fn, unsigned char* buf , int rows, int cols){
	// #define OF_W (ios::out|ios::trunc)
	int i = 0; 
	int j = 0;
	string sb = ""; 
	for(i=0;i<rows;i++){
		for(j=0;j<cols;j++){
			//buf[i*cols+j] = (i+j)%255; 
			unsigned char t = buf[i*cols+j]; 
			sb += to_string_( (int)(t) );
			sb += " ";
		}
		sb += "\n"; 
	}
	ofstream of_(fn.c_str(), OF_W); 
	of_ << sb ; 
	of_.flush();
	of_.close(); 
} 
#define  JD_LOGE_9(STR) \
	static int cnt_9 = 0; \
if ( cnt_9++ == 0 ){ \
	LOGE("--- JD LOG_9 %s: function:%s, line:%d----",STR,  __FUNCTION__, __LINE__); \
} \
; 


//perl append 
open my $FP, ">>$FN";
close $FP;
// g++ -std=c++11 setenv.cpp  && time ./a.out
// setenv 
// perl -e 
#include <stdlib.h>
#include <stdio.h>

#ifdef _MSC_VER 
#define putenv _putenv
#endif

// #define PERL_INTERP_START  "perl -e \"  
// #define PERL_INTER_END \"  "

int main() {

                putenv((char*)(
                     "abc=abcvarEND2 "
                     ));


#ifdef _MSC_VER 
        system(
                " perl -e \" \
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \
                     print @ENV{abc}x2;                                 \
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; \
                     \"  "
        );
#else 
        system(
                " perl -e \' \
                     $_______________________________; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     print @ENV{abc}x2; \
                     $_______________________________; \
                     \'  "
        );
#endif 

return 0; 

}

# !/bin/bash
export now=`date "+%Y%m%d_%H%M"`
#echo cur pid is $$ 

export out_file=cpu_perc_${now}.txt

export PID0_PID1=$( pgrep -f watchdog.py | perl -e ' map{chomp; my @t=`ps af |grep $_`; @t = grep m/\\_ \./,@t; $_=@t[0];@tt0=split; $_=@t[1]; @tt1=split; print @tt0[0], " ", @tt1[0]; }<>'  )
#echo ${PID0_PID1}


while true;do
        export  now=`date "+%Y%m%d_%H%M"`
        perl -e ' open $FP, ">>@ENV{out_file}";  $now=@ENV{now};   $_=@ENV{PID0_PID1}; @t=split; map{ @top_log=`top -b -p @t[$_] -n 1`;   $_= @top_log[-1]; @pid_cpu=split;$w=qq($now,@pid_cpu[11]=@pid_cpu[8],); print $w; print $FP $w;}(0..1);  print qq(\n); print $FP qq(\n); close $FP;   '
        sleep 5s
done




exit 0

// shell bash perl
#!bash 


perl -e '  
### perl start ###
        @a=(0..9); 
        print "@a" x 5;
### perl end ###
'  > txt.txt 

#!perl
use strict ;
### global var ###
my $roi_idx = 2; 
my $filter_num = 144.00;
##################
my @arr_content = (); 
die "- no argv, please run\n\tperl test.PL cpu_perc_3082_20170614.txt\n" if  @ARGV == 0; 
q( 
####### filename ######## 
"                        "
DATA :
20170614_2346,tmpdata=212.8,20170614_2346,sonogui=6.647,  
20170615_0210,tmpdata=19.6,20170615_0210,sonogui=6.634,
20170615_0210,tmpdata=199.6,20170615_0210,sonogui=6.634,
"                        "
##########################
); 

my $filename = @ARGV[0] ; 
@arr_content = `cat $filename| grep 2017`;
@arr_content = 	sort { &parse_roi_num($a) <=> &parse_roi_num($b) }   @arr_content ; 
@arr_content = &filter_ascend_arr_by_cond(\@arr_content, $filter_num);
my @arr_to_av = &get_out_roi_arr(\@arr_content); 
my $len = @arr_to_av; 
my $average_num = &aver(\@arr_to_av); 
print qq(\$average_num of \$len $len is $average_num \n); 




### sub list ### 
sub get_out_roi_arr(\@){
	my $addr = shift @_;
	my @arr_ret = (); 
	for my $e (@$addr) {
		push @arr_ret , &parse_roi_num($e);
	}
	return @arr_ret ; 
}
sub filter_ascend_arr_by_cond(\@ $){
	my $addr = shift @_; 
	my $filter_num = shift @_; 
	my $cnt = 0; 
	while(1){
		my $__ = @$addr[$cnt++] ; 
		last if &parse_roi_num($__) > $filter_num; 
	}
	my $len = @$addr;
	my @arr_content = @$addr[ $cnt..$len-1] ; 
	return @arr_content; 
}
sub parse_roi_num(){
	my $line = shift @_;
	my @t = split m/[\,\=]/, $line; 
	return @t[$roi_idx];
}
sub aver(\@){
	my $addr = shift @_;
	my $len = @$addr ; 
	my $sum =0; 
	for my $e (@$addr) {
		$sum += $e; 
	}
	return $sum/$len;
}


// read file to uchar buf , and show as img 
using namespace std;



#define OF_W (ios::out|ios::trunc)
#define IF_R (ios::in)




template<typename T>
string to_string_(T n){
    ostringstream ss; 
    ss << n ;
    return ss.str();
}
void write_buf_2_file(const string & fn, unsigned char* buf , int rows, int cols){


    // #define OF_W (ios::out|ios::trunc)

    int i = 0; 
    int j = 0;
    string sb = ""; 
    for(i=0;i<rows;i++){
        for(j=0;j<cols;j++){
            //buf[i*cols+j] = (i+j)%255; 
            unsigned char t = buf[i*cols+j]; 
            sb += to_string_( (int)(t) );
            sb += " ";
        }
        sb += "\n"; 
    }

    ofstream of_(fn, OF_W); 

    of_ << sb ; 
    of_.flush(); 

    of_.close(); 

}




int _tmain(int argc, char** argv)
{


    const int rows = 512; 
    const int cols = 590; 
    unsigned char buf[rows*cols] = {0}; 
    int  a = 0; 

    int cnt = 0; 

    double Time = (double)cvGetTickCount();

    ifstream if_( "x:\\512x590_imgdata.txt" , IF_R ); 
    // filecontent is: 512*590 : 121 55 22 0 9 
    //ifstream if_( "x:\\txt.txt" , IF_R ); 
    while( 1 ){
        if_ >> a ; 
        if (if_.eof()) break;
        buf[cnt++] = (uchar)a; 
        //printf( "%d \n", a); 
    }
    if_.close(); 


    Time = (double)cvGetTickCount() - Time;

    printf( "run time = %gms\n", Time /(cvGetTickFrequency()*1000) );

    cout<< to_string_(int(buf[ rows*cols-6 ])) ;  

    Mat id_m(rows, cols, CV_8UC1); 
    int cntt = 0; 
    for( int i=0;i<rows;i++){
        for( int j=0;j<cols;j++){
            auto &t = id_m.row(i).col(j).data[0];
            t = buf[cntt++];    
        }
    }


    imshow( "id_m", id_m); 

    imwrite( "x:\\id_m.bmp", id_m); 
    waitKey(0);

    __P__; // system("pause");
    return 0;
} // end main()






///////
// read txt to img and buf iplimage 

void read_file_2_iplimage_and_show(string& fn, int rows, int cols ){

    int rows_ = rows;
    int cols_ = cols;
    int i =0; 
    int j =0; 
    IplImage *id_m = cv_c( cvSize(cols_, rows_), 8, 1 );  // mem 0
    //int rows = id_m->height; 
    //int cols = id_m->width;
    int step = id_m->widthStep; 


    ifstream if_( fn.c_str(), IF_R ); 
    int x = 123 ;

    for( i=0;i<rows; i++){
        for( j=0;j<cols; j++){
            char &tt = id_m->imageData[i*step+j]; 
            if_ >> x ; 
            tt = x ; 
        }
    }

    show_iplimg( id_m ); 
    cvReleaseImage( &id_m ); 
}


int _tmain(int argc, char** argv)
{
    int rows = 600; 
    int cols = 510;
    read_file_2_iplimage_and_show(string("x:\\pBufsc.txt"), rows, cols ); 

    __P__; // system("pause");
    return 0;
} // end main()

// perl get_timestamp 
#!perl

print &get_timestamp(); 







### sub list ### 
### perl timestamp ### 

sub add_zero_if_lt_10($){
	my $num = shift @_; 
	if ($num >=10 ){
		return "$num" 
	}
	return "0$num"; 
}
sub get_timestamp(){

# perl get time, for second:
 #perl -e 'print $^T '
#1477400615
my $if_windows = "False"; 
$if_windows = "True" if @ENV{WINDIR}; 


    my $time_stamp = `date "+%Y%m%d_%H%M"` if $if_windows ne "True"; 

    if ( $if_windows eq "True"){
        my ($second, $minute, $hour, $date, $month, $yearOffset, $dayOfWeek, $dayOfYear, $daylightSavings) = localtime();
        # 17 16 20 24 7 116 3 236 1
        # 2016-08-24 20:16

        my $year = 1900 + $yearOffset;
        $month = $month + 1 ; 
        $month = &add_zero_if_lt_10($month); 
        $date = &add_zero_if_lt_10($date); 
        $hour = &add_zero_if_lt_10($hour); 
        $minute = &add_zero_if_lt_10($minute); 
        $time_stamp = "$year$month${date}_${hour}$minute"; 
    }

    chomp( $time_stamp ); 
    my $suffix_ = ""; 
    return "$suffix_".$time_stamp; 

}


EOF

/*
// move to another header file 
#define TO_STRING_  string to_string_(T tt) { \
stringstream ss; \
ss << tt; \
cout << ss.str(); \
return ss.str(); \
} \
;
#define S(x) to_string_((int)(x))
*/

template <typename T> TO_STRING_;    // to use to_string_(id_m)


#include <stdlib.h>
#include <stdio.h>

#ifdef _MSC_VER 
#define putenv _putenv
#endif



#define M_PI       3.14159265358979323846
int _tmain(int argc, char** argv)
{
 
    int n = 99; 
    char *env_n="env_n"; 
    string id_ss = string(env_n) + string("=") + S_( (int)&n ) ; 
    putenv( id_ss.c_str() ); 

  

    int *naddr =(int*) atoi(  getenv(env_n)  ); 
    int n_new = naddr[0]; 
    //cout << n_new << endl;  // => 99

    naddr[0] = 999; 
    cout << n << endl;  // => 999 


// mutex 
pthread_mutex_t mutex[DMA_NUM];
	    pthread_mutex_lock( &mutex[info.dma_no] );
	    ret = Do_sth(PiqHandle, &data);
	    pthread_mutex_unlock( &mutex[info.dma_no] );
		pthread_mutex_destroy(&mutex[i]);
    ifstream vfile("CFMdata/config.ini");
    
    if (vfile.is_open())


#c is file  exist 
    while(1){
// #include <io.h>
        if ( _access( "x:\\txt.txt", 0 ) != -1 ){
            cout << "- _access exist " << endl; 
        }

        ifstream if_("x:\\txt.txt", F_R); 

        if ( if_.is_open() ){
            cout << "- ifstream exist " << endl; 
        }
        if_.close();
        cout << "- sleep 2s\n"; 
        Sleep(2000);
    }
### matlab_ ### 

type txt.txt
pwd
[x, y] = size(id_m)

-fprintf
fp = fopen ( 'x:\\txt.txt', 'w'); 
fprintf(fp, '%d', a);
fprintf('%d\n',88)  %to stdout 
t=sprintf('%d', 88)
str2num(t)+1   % => 89
fclose(fp);
-
% this will be :   1.0000000e+00   0.0000000e+00   0.0000000e+00
save  a.txt  -ascii a   
can use read_file_2_float_buf_1d() to read 

-open close 
function fcout(id_m, idx)
% usage :
% fcout( id_m , 1111 ) 
% also can use "load xxxx_txt" or "loat xxx.txt" to load 
% ==> x:\txt_1111_8_x_8_txt
% === dlmwrite('x.txt', rand(9), ' ' )
[r,c] = size(id_m);
fn = sprintf( 'x:\\txt_%s_%0d_x_%0d_txt' , num2str(idx), r,c );
fp = fopen(fn, 'w');

for i=1:r
    for j=1:c
            fprintf( fp, '%d ', id_m(i,j) );
    end
    fprintf( fp, '\n' );
end 
disp(fn)
-

if 1 == 1 && 2 == 2
  disp(1)
end

if 1 ~= 2 


x(1:2,:)

- a m file with different function 
>> type t.m

function tt=t(a)
tt=t1(a)+t2(a);
end

function t1_=t1(a)
t1_=a;
end

function t2_=t2(a)
t2_=a;
end
-

strcat( 'abc', '4' )
-img 
lena=imread('x:\\lena.bmp');
lena(1:44,1:44) = 0; 
imshow(lena);

plot(xx,yy, 'b.');
-




// cv mat new usage 
Mat id_m = Mat( rows, cols, CV_8UC(1), pData, cols ); 

---dot_ ---
dot -V
dot -Tpng test.dot -o test.png & ecd test.png
http://blog.jobbole.com/94472/  demo
digraph "server"
 {
 graph["splines"="curved","overlap"="scalexy","rankdir"="LR"]
 node["fontsize"="8px","fontname"="arial","shape"="rect","margin"=0,"pad"=0,"style"="solid"]
 "1" -> "2" ;
 }
/* no direct */
graph abc{
a -- B;
B -- a[color=red];
}
digraph abc{
 "a b c" -> b;
 b -> c;
} 

graph minimal_nonplanar_graphs {
  size="9,19"

  URL="http://en.wikipedia.org/wiki/Kuratowski_theorem#Kuratowski_subgraphs"
  tooltip="click for \"Kuratowski theorem\""
  JD="JD"
  labelloc=t           
  label="Minimal nonplanar graphs (9 edges / 5 nodes)"
  node [style=filled]

  subgraph cluster_0 {
bgcolor="yellow";
    label="K_3,3"  color=lightblue  style=filled
    node [color=white]
    {A B C} -- {D E F}
  }

  subgraph cluster_1 {
    label=K_5  color=blue
    node [color=yellow  shape=box]
    1 -- {2 -- {3 -- {4 -- 5}}}
    } 
}

graph minimal_nonplanar_graphs {
  size = "8,8";
  subgraph sub_0{
    a [shape=box,fillcolor=green,/*style=dashed,*/style=filled];
    b;
    c;
    d;
    {a,b} -- {c,d};
  }
}
digraph sub_0{
  labelloc=t  
  label="this is a label"
  node [shape=record];  //rect
  edge [style=dashed];  //虚线
    a;
    b;
    c;
    d [shape=none, image="t.png" , label=""];
    a -> { b -> { c -> d[color=red] } } ;
  }

digraph abc{

  node [shape="record"];
  edge [style="dashed"];

  a [style="filled", color="black", fillcolor="chartreuse"];
  b;

    subgraph cluster_cd{
      label="c and d";
      bgcolor="mintcream";
      c;
      d;
    }

  a -> b;
  b -> d;
  c -> d [color="red"];
}
//table 
digraph abc {
//rankdir=TB;
node [shape=record,color="skyblue",];
// node [shape="plaintext"]; 
edge [];
a;
1;
0 [shape=doublecircle , style=filled];
A;
a [label="
{<a_>a|
b|
c}
"];
1 [label="1|<_2_>2|3|4"];
A [label="A|B|C"];
1:_2_ -> a:a_;
1 -> A;
  0 ->0 [label="fuck self",shape=diamond];  // shape = "Mrecord",   圆角矩形

}

-
  rankdir = "TB";  // LR 
  fontname = "Courier New"
  fontsize = 100; // big picture

  node [shape = doublecircle];
  
LR_0 LR_3 LR_4 LR_8; 
-
-time sequence-
digraph G {
size="10,10"
rankdir = "LR";
node [shape="point",width=0, height=0];
edge [ arrowhead=none];

{
rank = "same";
a[shape=plaintext]
a -> a0 -> a1 -> a2 -> a3 -> a4; 
}

{

rank = "same";
b[shape=plaintext]

b -> b0 -> b1 -> b2 -> b3 -> b4; 
}

edge[arrowhead=""];

a0->b0;
a1->b1;
b2->a2;
}
-


    //--- cv draw rotate rectangle 
#define IMG_WIN_HEIGHT 820
#define IMG_WIN_WIDTH 1130

#define LINE_P_NUM 10000

    const int rows =  IMG_WIN_HEIGHT;
    const int cols =  IMG_WIN_WIDTH;

    Mat id_m( rows, cols, 0); 
    clear_img( id_m );

    string id_s("");
    RotatedRect rRect=RotatedRect(Point2f(cols/2,rows/2),Size2f(22,400),-30);
    Point2f vertex[4];
    rRect.points(vertex);//提取旋转矩形的四个角点
    for(int i=0;i<4;i++)
    {
        id_s += to_string_(vertex[i].x) + " " + to_string_(vertex[i].y) + "\n";
        line(id_m,vertex[i],vertex[(i+1)%4],Scalar(255));//四个角点连成线，最终形成旋转的矩形。
    }

    fcout( id_s , 1111);
    show_mat(id_m);
// end cv draw 
-


#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

int main(){

const char *s= string("abc 12345 bcd").c_str();
int a =0;
sscanf(s, "abc %d", &a);
cout << a<< endl;

}



import tensorflow as tf
import numpy as np
import re
import random
import os
print "- import end"
lines_to_return = (range(0,9))
lines_to_return[1] = 9
lines_to_return[2] = 9
print lines_to_return
### classv.PL ### 
*********************
\home\tanglq\t\classv.PL
*********************
#!perl
use strict;
# 1.put all the source file to one single file, .e.g: all_content.txt
# 2.run : cat all_content.txt | grep '^class ' | sort -u > txt.txt , 
#   this will grasp out class out;
# 3.run :
#   perl test.PL TO_FILTER_0 TO_FILTER_1 > test.dot 
# 4.show the dot file as png 
#
# usage :
#   perl test.PL K I Q
#
# written by Jidor Tang at 2017-8-5

if (@ARGV == 1 && @ARGV[0] eq "_all_"){
 @ARGV = ( "K", "Q", "I", "D", "P", "V", "T", "S", "N", "C" ); 
}
if ( -e "allclass.txt"){}
else {
	die "- no file \"allclass.txt\"\n";
}
my @vars = `cat allclass.txt|sort -u`;

my @arr = @vars ; 

### pre process ###
chomp(@arr);
@arr = grep !m/google/, @arr;
@arr = grep !m/\:\:/, @arr; 
@arr = grep !m/\;$/, @arr; 
my @arr_inherit = (); 

map{
	chomp;
	s/\;//g;
	s/\{//g;
	s/\s+/ /g;

	my @t = split m/\s+/; 
	if (@t[2] eq ':' || @t == 2){
		push @arr_inherit , (join ' ',@t); 
	}
}@arr;
my @after_filter = ();
my %hash =();
for my $t (@ARGV) {
	my $to_filter_t = $t; 
    if ($to_filter_t !~ m/\w/){
	  next;
	}
	my @arr_inherit_0 = grep m/$to_filter_t/i, @arr_inherit; 
	push @after_filter, @arr_inherit_0; 
}
@arr_inherit = @after_filter; 
@arr_inherit = grep { ++$hash{$_} < 2 } @arr_inherit;

my @all_graph = ();
### generate the dot graph ###
map{
	chomp;
	s/class //g;
	my @t = split;
	my $i=0;
	for ( $i=0;$i<@t;$i++){
	 if (@t[$i] eq ':'){
	 last;
	 
	 }
	}
	my @element = ();
	@element = ( @t[($i+1)..(@t-1)]  , " -> ",  @t[0..$i-1] ) if @t > 2; 
	@element = ( @t[0..1] ) if @t <= 2; 
	if ( @element[0] =~ m/public/ ){
	  push @element, ""; 
	}
	elsif (@element[0] =~ m/virtual/ ){
      push @element , "[style=dashed]";
	}

	#push @element, ";\n";
	if (@element == 2){
		unshift @all_graph , \@element; 
	}
	else { 
        push @all_graph , \@element ; 
	}
}@arr_inherit; 

### display ###
my $dot_statement = '
digraph abc{
randir="TB";
node[shape=record];
__STAT__
}

'; 
my $dot_kernel = ""; 
for my $t (@all_graph){
	my @element = @$t ; 
	my $outstr = "@element";
	$outstr =~ s/public //g;
	$outstr =~ s/virtual //g;
	$dot_kernel .= $outstr.";\n"; 

}
$dot_statement =~ s/__STAT__/$dot_kernel/; 
print $dot_statement; 

# cat pad_v_fe_be_cpp_h.cpp | grep  '^class ' | sort -u  > txt.txt 
# cat vm_cpp_h.cpp | grep  '^class ' | sort -u  > txt.txt

EOF

    auto b_flag_save =  QFile::exists("savedscimg");
    /*
    auto range_int=[](unsigned int uiMaxRange)
    {
        const unsigned int ONE_MILLISEC              = 1; //1毫秒
        const unsigned int ONE_SEC                   = 1000  * ONE_MILLISEC;
        QTime time;
        time = QTime::currentTime();
        qsrand(time.msec() + time.second() * ONE_SEC);
        int i_rand_num = qrand() % uiMaxRange + 1; // 1 ~ uiMaxRange
        return i_rand_num;
    };
    range_int(10);
    */

free -m 
to see free memory in device

# read and write binary #

ofstream of_( "x:\\txt.bin" , std::ofstream::binary); 
int i = 0x22333344;  // 00000000: 4433 3322     D33"
cout << i<< endl; 
of_.write(reinterpret_cast<char*>(&i), sizeof(i) ); 
of_.close();

ifstream _if_( "x:\\txt.bin", std::ifstream::binary); 
int j=0; 
_if_.read (reinterpret_cast<char*>(&j), sizeof(j) ); 
cout << j<< endl;
_if_.close(); 

x  = pd.read_csv( "txt.txt",sep=" ", header=None)

printf("%I64u\n",i<<62);


df = pd.DataFrame(  [ [1,2,3], [2,2,4] ] )
print (df)                 
for k,v in enumerate(df[2]):
    print ("k,v " + str(k) + " " + str(v))
# "date","sc","sn","mn","ayep",     "sp",     "hi",   "lo",       "ep",  "vo",   "tm",     "tt",      "yep"
# "date","sc","sn","mn","实际昨收盘","今开盘价","最高价","最低价","今收盘价","成交量","成交金额","成交笔数","昨收盘价"

-datetime-
import datetime 
id_dt_0 = datetime.datetime(2012, 4, 24, 15, 6, 0, 10)
id_dt_1 = datetime.datetime(2012, 4, 4, 15, 6, 0, 0)
id_dt_2 =  datetime.datetime(2012, 5, 4, 15, 6, 0, 100)
print ( str(id_dt_2 - id_dt_1) )  # '30 days, 0:00:00.000100'
ldt = [ id_dt_0 , id_dt_2, id_dt_1 ]
ldt.sort()

for i in ldt:
    print (i)
import dateutil
help ( dateutil )

from dateutil.parser import parse
a = (parse( "2017-08-19 21:00")) # Sunday
print (a.weekday()+1)  #  6 

def see_c_f(class_, fun_="", openhelp=0):
    """
    need : import numpy
    see_c_f ( np, "mat",0) 
    """
    name = (str(class_).split(" "))[1]
    name = name.replace("'","") +"."
    #print (name)
    assert(type(fun_) == type("str"))
    if fun_ == "" :
        print (dir(class_))
        return 0
    list_fun = dir(class_)
    for e_fun in list_fun:
        #print(i)
        if openhelp == 0 and not str(e_fun).find(fun_):
            print ( "- "+ (name + str(e_fun)).strip() + ""  )
        if openhelp == 1 and str(e_fun) == (fun_):
            print ("====== "+ (name + str(e_fun)).strip() + " ======")
            eval_statement = (name + str(e_fun)).strip()
            eval( " print ( " + eval_statement + "." + "__doc__" + ")" ) 


// generate all src code 
#!perl 
use strict;
my $curdir = `pwd`;
#curdir can be change here
chomp($curdir);
my @arr = `( find $curdir -name '*.h' ; find $curdir -name '*.cpp' ) | grep -v /depends/win/ | sort -r >  txt.txt `; 

@arr = `cat txt.txt`; 

@arr = grep !m/moc_/, @arr; 
@arr = grep !m/ui_/, @arr; 


my $len = @arr; 

#print @arr[0]; 

#@arr=(@arr[0],@arr[1]);

my $windows_path = 'V:\svn\br-1.8\src';

my @arr_all = &print_all_files( \@arr ); 
my $str_all = join '', @arr_all; 

open my $FP, ">", "vista_src_all_cpp"; 
	print $FP $str_all;
close $FP; 
system( " dos2unix  vista_src_all_cpp " ); 

print "- please run:\n\tcp vista_src_all_cpp \$t/vista_src_all_br_1_8.cpp\n " ;

### sub list ###
sub print_all_files(\@){
	my @arr_all = (); 
	my $addr_ = @_[0]; 
	my @ARGV_ = @$addr_;
	use feature qw(say); 

	my $NEED_ONLY_WINDOWS_NAME = 1;

	map{
		chomp;
		if(-T "$_") {
			push @arr_all,  "\n*********************\n";

			if ( !$NEED_ONLY_WINDOWS_NAME ){
				push @arr_all, $_."\n" ;
			}

			if ( $NEED_ONLY_WINDOWS_NAME ){
				my $t = $_; 
				chomp ($t) ;
				if ( $t =~ m/br\-1\.8/ ){	
					#$t =~ s/\/home\/tanglq\/depot\/br.1.4\/01_code/E\:\\br-1.4\\01_code/; 
					$t =~ s/\/data\/tanglq\/svn\/br.1.8\//V\:\\svn\\br-1.8\\/;
#my $windows_path = 'V:\svn\br-1.8\src';
				}
				else {
				  $t =~ s/\/home\/tanglq\/depot\/svn\/01_code/D\:\\trunk\\01_code/; 
				}
				$t =~ s/\//\\/g;
				push @arr_all,  $t."\n";
			}

			push @arr_all, "*********************\n";
			push @arr_all,  `cat $_`;
		}


	}@ARGV_;

	push @arr_all,  "EOF\n";

return @arr_all; 
}

// save vector data

  string id_save_data = "";

  for ( auto &t : vec_ngs_simu){
      cout << t.pkg_header.packet_counter << endl; 

      uchar * p_begin =  (uchar*)&t;
      uchar * p_end =  (uchar*)&t + sizeof(t);
      string s_tmp = string(p_begin, p_end);

      id_save_data += s_tmp;

  }
   
   FILE *fp = fopen("Z:\\t.txt", "wb"); 
   fwrite(id_save_data.c_str(), 1 ,id_save_data.size(),fp);

   fclose(fp);



#if 1
      
   FILE *fp_r = fopen("Z:\\t.txt", "rb"); 
   for(int i=0;i<num;i++){
       stru_ngs_simu_data each_pkg; 
       fread( (void*)&each_pkg, 1 ,sizeof(each_pkg),fp_r);
       cout << each_pkg.pkg_header.packet_counter << endl;  
   }
   fclose(fp_r);
#endif




<<<<<<< HEAD

// arr to string 	
#include <stdio.h>
#include <cstdarg>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <iostream>
using namespace std; 

template<typename T>
string to_string_(T n){
	ostringstream ss; 
	ss << n ;
	return ss.str();

}

template <typename T>
string arr_to_string_1d(T *buf, int len){
	string outs = ""; 
	for( int i=0;i<len;i++){

		outs += to_string_(buf[i]) + " "; 

	}
	outs += "\n";


	return outs; 
}

template <typename T>
string arr_to_string_2d(T *buf, int rows, int cols){
	string outs = "";
	for ( int i=0;i<rows;i++){
		for( int j=0;j<cols;j++){
			outs += to_string_(buf[i*cols+j]) + " "; 
		}
		outs += "\n";
	}

	return outs; 
}

int main(){



	float arr[] ={88.889, 999}; 

cout << arr_to_string_1d( arr , 2 ); 

float arr_2d[2 * 4]={
1 , 2 ,3,4,
2 , 2 ,4,4,
};

cout << arr_to_string_2d(arr_2d, 2, 4); 
return 0;
}

=======

git commit issue:
git commit -m'all'  -a 
git remote set-url origin https://github.com/tlqtangok/s.git

pandas plot scatter
# see_c_f(df,"ix")
df = df.reset_index()
df = df.head(4)
df = df.reset_index()
plt.xticks(np.linspace(0,5,6),np.array(df.dt),rotation=-30)
plt.yticks(np.linspace(0,1000000,9),np.linspace(0,1000000,9),rotation=30)
plt.plot(df.vo)
plt.show()
# plt.xticks?

# -----> 1
  |
  |
  0
df = df.drop(['tm','dt'],1) # del cols  

x = np.arange(9)
df = pd.DataFrame({
    'f0': x,
    'f1':x*3 -7,
    'f2':7/(x*1.0+1.0)
    
})

df.plot.bar(y=["f2","f0","f1"])
plt.show()
df.plot.scatter(x=["f0","f0"], y=["f2","f1"])
plt.show()

df["idx"] = np.arange(len(df))
df.plot.bar( x=["idx"],y=["f1","f2","f0"])
plt.show()

df["idx"] = np.arange(len(df))
df.plot.bar( y=["f1","f2","f0"])
plt.show()

df = pd.DataFrame(
[
 [1 ,2 ,3],
 [11 ,22 ,33]
],
 index = [0,1],
 columns = ["f0","f1","f2"]
)

df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df

df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df_ = pd.DataFrame(
np.mat("1 2 33; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)

pd.concat([df,df_])
df = pd.DataFrame(np.eye(3)).astype(np.int).rename(columns={0:"f0",1:"f1",2:"f2"})
df = pd.DataFrame(
np.mat("1 2 3; \
       4 5 6"),
 columns = ["f0","f1","f2"]
)
df_ = pd.DataFrame(
np.mat("1 2 33; \
       4 5 6"),
 columns = ["f0_","f1_","f2_"]
)

pd.concat([df,df_], axis = 1)

# => 0 2
     1 4
df = df.melt()  

df = df.rename(columns={'f0':'f00'})
df

df = df.query('f1 == 2')
df

df = df.sort_index(ascending=0)
df = df.reset_index()
df.drop(["index"],1)
df.drop([0] )  #drop one line 

df.filter(regex='f[1-2]')
df[["f0","f1"]]
df.loc[:1,"f0":"f2"]  # included !!! , different with np
df.loc[ df["f0"]>1 , :]  # can only use "f0"
df.loc[ df["f0"]>1 , ["f1","f0"]]
df.iloc[:1,0:2]  #not include, can not use "f0" , only number

df.drop_duplicates() # unique
df.sample(frac=0.5)  # randomly get half of item 
df.sample(n=2)
df.nlargest(2,'f0')
df.f0.value_counts()  # get a hash that indicate the number of each element 

df.nunique() 	# return the unique num of each field 

- qcut -
print df
ds = np.arange(8)
np.random.shuffle(ds)
print ds
df = pd.qcut(ds, 5, labels=["C-","C+","B", "A-", "A+"])
print df 
list(df) 

df.max(axis=1)
df.clip(lower=2, upper=3,axis=0 ) #trim to board is not in the range 

t = df.groupby(by="f0")
df.groupby("f0").size()

for i in t:
    print i[0]
    print i[1].values

-shift
df.shift(1,axis=1)

-merge 
df0 =  pd.DataFrame (np.mat( "1 2 ; 3 4"), columns=["f0","f1"])
df1 =  pd.DataFrame (np.mat( "1 2 ; 33 44"), columns=["f0","f1"])
pd.merge( df0,df1, how='outer')

-applymap
f = lambda x: str(x) * 3
df["f0_"] = df.applymap(f).f0
df["f0_"] = pd.DataFrame(df.f0).applymap(f)
pd.DataFrame(df.dt).applymap(lambda x : parse(x).weekday()+1)
df

df = pd.DataFrame({
    "dt" : ["20120901","20130909" ],
    "val":[1 ,2],
    "vo":[4,6]
})
df.pivot(index="dt", columns="val", values="vo")

val 		1 	2
dt 		
20120901 	4.0 	NaN
20130909 	NaN 	6.0

-numpy resize
id_m = np.mat("1 3").astype(int)
id_m.resize(3,3)
id_m

id_m = np.mat("1 2 4")
np.r_[id_m,id_m]
np.r_[3, [0]*5, -1:3:0.8]  # row array 
np.c_[id_m,id_m]

from numpy import poly1d
p = poly1d([2,3,4])
p(0) = 2x^2 + 3x^3 + 4

np.linalg.solve( np.mat("2 1;1 -1"), np.mat("2;1") )

plt.subplot(221)
plt.scatter( id_l, id_s)
plt.subplot(222)
plt.scatter( id_l, id_s)
plt.subplot(223)
plt.scatter( id_l, id_s)
plt.subplot(224)
plt.scatter( id_l, id_s)
plt.savefig("myf.jpg")
plt.show()

b = np.mat([1/4.0, 3/4.0][::-1]).T  # reverse list 

-cal the split of coorx0
x0 =  0
x1 = 10
a = np.mat( [x0,x1]) 
# a => lambda 
lambda_ = 1/10.0
b = np.mat([lambda_, 1-lambda_][::-1]).T
(a * b)[0,0]
-
from scipy import linalg , sparse
a = np.mat("1 0   ;0 9")
print linalg.sqrtm(a)
-
a = np.mat("1 3")
b = a
print (a * b.T)[0,0] == np.tensordot(a,b)
-
a = np.mat("3 -1 ;-1 3")
a = linalg.funm(a, lambda x: x*10)
a
-

// str serial bin file

//  xxd -i -c 244 one_frame_ngs_simu.dat
// str serial bin file 
template <typename T>
string serial_2_str( T&  pt)
{
	string id_s = ""; 
	char *c_pt = (char*)&pt; 
	id_s += string(c_pt, c_pt + sizeof(T)); 
	return id_s ; 
}

void str_2_bin_file(string fn, const string& str_to_serial)
{
	ofstream of_( fn.c_str(), ios::binary); 
	of_ << str_to_serial;  // never have "<< endl";
	of_.close();
}

string bin_file_2_str(string fn){
	ifstream if_(fn.c_str(), ios::binary); 
	
	string id_s = "";

	char c = 'E'; 
	

	while(!if_.eof()){
		if_.read(&c,1); 
		id_s.push_back((uchar)c);
	}

	//id_s.get_allocator.capacity(99);

	if_.close();
	// cout << id_s.size() << endl;   // if 4 + 4, then it is 8
	// const char* mydata = id_s.data(); 
	// cout << *(uint32_t*)mydata;
	// cout << (uchar)&str[3]
	return string(id_s.begin(),id_s.end()-1); 
}







// int main(
int _tmain(int argc, char** argv)
{

#if 1

	
	uint32_t a = 999; 
	uint32_t b = 9999; 


	string id_str = serial_2_str(a) + serial_2_str(b); 
	str_2_bin_file( string("d:/j/txt_txt"),id_str ); 

	string str =  bin_file_2_str( string("c:/j/txt_txt")); 
	cout << *(uint32_t*)(string(str.begin()+ 4 , str.begin()+ 8).data()) << endl;   // 9999
#endif




#if 1

	string fn = "D:\\j\\txt_txt";
	system((string(" del ") + fn ).c_str());

	uint64_t a= 99; 
	float f  = 88.88; 

	auto tt =  serial_2_str(a) + serial_2_str(f); 
	cout << tt << endl; 
	str_2_bin_file( fn, tt); 
	system((string(" xxd -i ") + fn ).c_str());

	cout << bin_file_2_str(fn)  << endl; 
	string p = bin_file_2_str(fn);
	cout << *(float*)(&p[0] + sizeof(uint64_t))  << endl; 



	struct AA{
		uint64_t a;
		float f  ;

	};

	auto p_id_a = (AA*)(&p[0]);
	cout << p_id_a->a  << endl; 
	cout << p_id_a->f << endl; 


#endif 


printf("0x%02x", (uchar)c); 


// vector usage 
#if 1

	vector<int> vec_c; 
	vec_c.resize(10+1); 
	vec_c[10]= 99; 

	for (auto i : vec_c){
	  cout << i << endl; 
	}


	auto p_int = vec_c.data();

	cout << p_int[10] << endl; 

	cout << vec_c.size() << endl; 

	vec_c.clear();
#endif

### get all perl src code ###	
my @arr = `( find $curdir -name '*.PL';find $curdir -name '*.pl'; find $curdir -name '*.t' ; find $curdir -name '*.pm' ) | grep -v /depends/win/ | sort -r >  txt.txt `;

// get col = ? , get cols value arr_col
 export arr_col="0 1"  && perl -pe '@arr_col=split / /,@ENV{arr_col}; @t = split; @ans=(); push @ans , @t[$_] for @arr_col; $_= "@ans". "\n";  '  txt.txt 


*********************
/home/tanglq/perl_p/ff.PL
*********************
#!perl
use strict;
use Data::Dumper; 
use feature qw(say);

=pod
fetch field from txt files

*** txt.txt ***
1 2 3
4 5 6
7 8 9
-----

run :
	perl ff.PL txt.txt 1 -1
=>
1 3
4 6
7 9
-----

=cut
die "- need 2 args, perl this_file.PL filename.txt \"arr_cols\"\n" if @ARGV < 2; 

my $fn = @ARGV[0];
my @fc = `cat $fn`; 

@ENV{arr_cols}=join " ", @ARGV[1..@ARGV-1]; 

my @arr_col=split / /,@ENV{arr_cols};
@arr_col = grep m/\w/,@arr_col;

my @ans_all = (); 
my @t = (); 
for (@fc) {
	chomp;
	my @arr_fc_each = split; 

	my @ans_each=(); 
	push @ans_each , @arr_fc_each[$_] for @arr_col;
	$_= "@ans_each";    

	#say  ; 

	push @ans_all, $_; 
}

say join "\n", @ans_all; 
#say ; 


#export arr_col="0 1"  && perl -pe '@arr_col=split / /,@ENV{arr_col}; @t = split; @ans=(); push @ans , @t[$_] for @arr_col; $_= "@ans". "\n";  '  txt.txt 






EOF

#perl and 
say if m/a/ and !m/A/; 

say if m/--c/ ;
use Cwd;
use File::Path;
use File::Find;

find({
		no_chdir=>1,
		wanted => sub{
			          say  ;
		             }
	},'.');

find({
		no_chdir=>1,
		wanted => sub{
			          say  ;
		             }
	},'/home/tanglq/t/tlq/');

my $cwd = cwd; 
print $cwd ; 

#!perl
# chinese enable #
use strict;
use File::Spec::Functions;
use feature qw(say);
use Cwd;
use File::Path;
use File::Find;



### global var ###
my $fn_output = "txt.txt";
##################



chdir(@ENV{vm}); 
my $cwd = cwd; 


my @fc_all = (); 
my @fn_all = (); 

@ENV{WINDIR} or die "- must Windows\n"; 
# find $curdir -name '*.h' ; find $curdir -name '*.cpp' ) | grep -v /depends/win/ | sort -r >  txt.txt `; 

find({
		no_chdir=>1,
		
		wanted => sub
		{
		  if ( /\.h$/ || /\.cpp$/   )
		  {
		 	  push @fn_all, $_ if !m|.depends.win.| and !m/ / and !m/bak\./ and !m/bak_script/; 
		  }
		}
		 
	},$cwd);

@fn_all = reverse sort @fn_all; 


for (@fn_all)
{
  push @fc_all, &get_fn_fc($_);
}

open my $FP, ">", $fn_output; 	
 print $FP @fc_all;
close $FP; 



sub get_fn_fc($fn)
{
  my $fn = shift; 
  $fn =~ s|\/|\\|g;
  my $id_s = "";
  $id_s .= "\n****************************\n"; 
  $id_s .= $fn; 
  $id_s .= "\n****************************\n"; 
  my @fc = `type $fn`; 
  $id_s .= "@fc"; 
  return $id_s;
}



# perl count 
$_ = qq(abcaba0); 
$_ = (tr/0/0/); 
say ;  # => 1


// gdb 
dump mem test.bin buf buf+100


# perl version 
print $] ;  # => 5.024001

*********************
/home/tanglq/t/jd_estimate_time_usage.txt
*********************
#include <time.h>
#include "opencv2/opencv.hpp"
#ifdef _MSC_VER 
#include "Windows.h"
#define putenv _putenv
#endif
//#define JD_ printf("- JD_ %s: %s: %d\n", __FILE__, __FUNCTION__, __LINE__) 
#define JD_ ((void)0) 
#define JD_SHOW_DIFF(R0) JD_;_JD_SHOW_DIFF(R0)


double JD_RT(char *tag)
{
	double Time = (double)cvGetTickCount();
	double ret_d =  Time / (cvGetTickFrequency() * 1000 ) ;
	printf("- JD time %s %gms\n",tag, ret_d); 
	return ret_d;
}

double JD_TIME_R0()
{
	double Time = (double)cvGetTickCount();
	return Time; 
}

void _JD_SHOW_DIFF(double R0)
{
	double jd_diff = (double)cvGetTickCount() - R0; 
	printf( "%.2f ms\n", jd_diff /(cvGetTickFrequency()*1000) );
}

#define FILE_STUB "jd_test"
static int flag_file_exist = 0; 			




// int main(

int _tmain(int argc, char** argv)
{


#if 1

	system("lsh");

	
	while(1)
	{


		if(0 != _access(FILE_STUB, 0)){
			flag_file_exist = 0;  // this process only take less than 1ms
		}
		else {
			flag_file_exist = 1; 
		}



		if ( flag_file_exist )
		{
			JD_RT("t0_scthread"); 
			double r0_scthread =   JD_TIME_R0();

			Sleep(2000);
			// do something 
			JD_SHOW_DIFF(r0_scthread);
		}


		Sleep(1000);
	}
#endif



EOF

# xxd 
xxd -ps , then use perl pack("H*", $output)
unpack("A*", $bin);

*********************
/home/tanglq/perl_p/num_arr_format_to_dec.PL
*********************
# perl any num format to dec 
#!perl
use feature qw(say);


my $fn = "";

$fn = @ARGV[0] if @ARGV;
die "- perl test.PL fn.txt\n" if ! -e $fn; 

my @fc = `cat $fn`; 


for my $e_l (@fc)
{
	say &p_e_l($e_l);
}



sub p_e_l($)
{
	my $e_l = shift; 
	my $ret_str = "";
	my @arr_e = split m/ +/, $e_l;
	@arr_e = grep !/^\s/, @arr_e;
	for (@arr_e)
	{
		my $t = 0; 
		if ( m/^[\-0-9]/ || m/^0x/ )
		#if ( m/^0x/ )
		{
			eval qq(\$t = $_;); 
			#my $str = sprintf "0x%0x ", $t;
			my $str = sprintf "%3d ", int( $t + 0.5);
			$ret_str .= $str;
		}
		else 
		{
			die "- error, num $_\n"; 
		}

	}
	return $ret_str; 
}

# cout << read_file_2_mat(string("x:/txt.txt"), rows, cols);
# [17, 34, 3, 85;
#   68, 17, 2, 5]

# usage
#   perl   $perl_p/hex_to_dec.PL txt.txt
#   txt can be "0x9 10 1e+10"


EOF

### numpy plot_xy ### 
import tensorflow as tf
import numpy as np
import re
import random
import os
import matplotlib.pyplot as plt
import pandas as pd
from scipy import linalg , sparse


#from __future__ import print_function

# "date","sc","sn","mn","ayep",     "sp",     "hi",   "lo",       "ep",  "vo",   "tm",     "tt",      "yep"
# "date","sc","sn","mn","实际昨收盘","今开盘价","最高价","最低价","今收盘价","成交量","成交金额","成交笔数","昨收盘价"

def read_file_to_arr( id_filename): 
    file = open(id_filename);
    lines = file.readlines();
    file.close(); 
    return lines



def load(fn):
    fc = open(fn).readlines()
    fc = [e for e in fc if len(e.strip())]
    id_str = ""
    for i in fc[:-1]:
        id_str = id_str + i.strip() + ";"
        
    id_str = id_str + i.strip()
    
    id_m = np.mat(id_str)
    return id_m

def plot_xy(id_m):
    plt.scatter( list(id_m[:,0]), list(id_m[:,1]),s=0.5)
    plt.show()
    
def see_c_f(class_, fun_="", openhelp=0):
    """
    need : import numpy
    see_c_f ( np, "mat",0) 
    """
    name = (str(class_).split(" "))[1]
    name = name.replace("'","") +"."
    #print (name)
    assert(type(fun_) == type("str"))
    if fun_ == "" :
        print (dir(class_))
        return 0
    list_fun = dir(class_)
    for e_fun in list_fun:
        #print(i)
        if openhelp == 0 and not str(e_fun).find(fun_):
            print ( "- "+ (name + str(e_fun)).strip() + ""  )
        if openhelp == 1 and str(e_fun) == (fun_):
            print ("====== "+ (name + str(e_fun)).strip() + " ======")
            eval_statement = (name + str(e_fun)).strip()
            eval( "print( " + eval_statement + "." + "__doc__" + ")" ) 

        
id_m = load("txt1.txt")
plot_xy(id_m)


#if _draw_convex_picture
	float R ; 
	float theta; 

	int MAX = 100; 

	float R_all = 22.0; 
	float start_a = -120; 
	float end_a = -20; 


	float d_a = (end_a-start_a) * M_PI / 180 / MAX * 1.0f ; 

	float d_r = R_all / MAX * 1.0f; 

	string id_s = ""; 
	
	for (int i=0; i< MAX; i++)
	{
		R = 0 + i * d_r; 
		for (int j=0; j<MAX; j++)
		{
			float b = d_a * j + start_a * M_PI / 180.0f ; 

			if ( R > R_all / 4.0f)
			{
				id_s +=  to_string_( cosf(b) * R )+  " "  +  to_string_(sinf(b)*R) + "\n" ;
			}

		}


	}

	fcout(id_s, 1111); 
#endif 

# python grep 
arr = [ e for e in list_i if m(e,"a") ]

# rm some file with '-p'
perl -e ' unlink(q(-p));'

*********************
split_perl_show_file.PL
*********************
#!perl
use feature qw(say);
use File::Basename qw(dirname);

my @arr = `cat txt.txt`;

my $i; 

my @ans = ();
for ($i=0; $i< @arr-3; $i++)
{
	if ( @arr[$i+0] =~ m/^\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ 
		&& 
		@arr[$i+2] =~ m/^\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ 
		&& 
		@arr[$i+1] !~ /^\s/)
	{
		
		#say $i , " " , @arr[$i+1] ; 
		push @ans, $i+1; 

	}

}



for($i=@arr - 1; $i>0; $i--)
{
	if (@arr[$i] =~  /^EOF.?$/)
	{
		last;
	}
}

push @ans, $i+1; 


my $len_ans = @ans; 

#my $idx = $len_ans -1 -1 - 0; 

for(my $j=0; $j<@ans-1; $j++)
{
	my $idx = $j; 
	my $fn_idx = @ans[$idx];
	my $fn = @arr[$fn_idx]; 
	chomp($fn);
	my $dirname_fn = dirname($fn);
	`mkdir -p $dirname_fn`;
	my @fc =  @arr[@ans[$idx]+2..@ans[$idx+1]-2] ; 
	open my $FP, ">", $fn or die; 
	print $FP @fc;
	close $FP; 
}

EOF

-

	// #include <stack>
	stack<int> id_stk; 

	int  arr[100];
	int cnt = 0;
	for (auto i : arr)
	{
		id_stk.push(cnt++);
	}

	int t = 0;
	id_stk.pop();
	t = id_stk.top();
	cout << t << endl; 


// read sam files  2018-01-24 in bgi
// t0.cpp : 定义控制台应用程序的入口点。
// g++ -std=c++11 test.cpp  -l pthread


//#include "stdafx.h"


#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <stdint.h>  // uint64_t
#include <assert.h>

#include <vector>
#include <sstream>
#include <map>
#include <algorithm>    // std::sort
#include <utility>

#include <stack>

#ifdef _WIN32
        #include "winpthreads.h"
#else
        #include <pthread.h>
        #include <pthread.h>
        #include <unistd.h>
        #include <sys/wait.h>
        #include <sys/types.h>
#endif



using namespace std;


#ifdef _MSC_VER
string fn = "E:/jd/t/test.sam";  // filename of sam
#else
//string fn = "./test.sam";
string fn = "./test_1kw.sam";
#endif


//#define __P__  system("date /t")
#define __P__  system("pause");return 0;

const char* CONST_STR_PG = "@PG\t";
const char* CONST_STR_PG_NO_TAB = "@PG";
const char* CONST_STR_SQ = "@SQ\t";
const char* CONST_STR_SQ_NO_TAB = "@SQ";
const char* CONST_INVALID_FLAG = "4";
const char* CONST_INVALID_XT_VALUE = "XT:A:R";
const uint64_t CONST_LEN_OF_READ = 35;
auto F_R = (ios::in);
const int MAX_CHAR = 128 * 4;


/////////////////////////////////////////////////////////////////////////////////
/*
const char* CONST_STR_PG = "@PG\t";
const char* CONST_STR_SQ = "@SQ\t";
const char* CONST_INVALID_FLAG = "4";
const char* CONST_INVALID_XT_VALUE = "XT:A:R";
const uint64_t CONST_LEN_OF_READ = 35;
const int MAX_CHAR = 128 * 4;
*/



void Stop(int signo)
{
        printf("oops! stop!!!\n");
        _exit(0);
}

void * f_sort(void * p_vect_)
{
        auto p_vect = (vector<uint64_t>*) p_vect_;
        std::sort((*p_vect).begin(), (*p_vect).end());
}

void throw_map_vect_2_threads_and_run(map<string, vector<uint64_t> >& map_chr_visit_pos)
{
        signal(SIGINT, Stop);

                pthread_t arr_t_sort[200];
                int cnt = 0;

                for( auto& e_chr_name: map_chr_visit_pos)
                {
                    //auto chr_name =  e_chr_name.first ;
                        auto& e_vect = e_chr_name.second;
                        if(e_vect.size() > 500)
                        {
                                auto res = pthread_create(&arr_t_sort[cnt], NULL, f_sort, &e_vect);
                                cnt++;
                        }
                        else
                        {
                                //std::sort(e_vect.begin(), e_vect.end());
                                f_sort(&e_vect);
                        }
                }


                for(auto i=0;i<cnt;i++)
                {
                        auto res = pthread_join(arr_t_sort[i], NULL);
                }
}


class CSamParser
{
public:
        CSamParser(const string &fn_sam);
        ~CSamParser();
        void display(int disp_level);
        void save_map_to_file(const string& fn_chr_len, const string& fn_chr_visit_pos);
        int get_visit_deepth(const string& chr_name, uint64_t detect_loc);


private:
        string fn;
        map<string, uint64_t> map_chr_len;
        map<string, vector<uint64_t> > map_chr_visit_pos;

        vector<string> split_str_2_vec(string &str, const char delimiter);

        string e_line;  //tmp line from file handler if_
        void read_sam_file_2_two_maps();

        void display_map_chr_len();
        void display_map_chr_visit_pos();

        string fcout(const string& fn, const string& id_s);
        CSamParser(); // invalid this default contructor
        template<typename T> string to_string_(T f)
        {
                ostringstream ss;
                ss << f;
                return ss.str();
        };
};
////////////////////
CSamParser::CSamParser()
{
}
void CSamParser::display(int disp_level)
{
        switch (disp_level)
        {
        case 0:
        {
                display_map_chr_len();
                break;
        }
        case 1:
        {
                display_map_chr_visit_pos();
                break;
        }
        default:
        {
                display_map_chr_len();
                cout << endl << "------------------------" << endl;
                display_map_chr_visit_pos();
                break;
        }

        }

}

void CSamParser::save_map_to_file(const string & fn_chr_len, const string & fn_chr_visit_pos)
{
        string id_s_map_chr_len = "";
        for (auto e_map_chr_len : map_chr_len)
        {
                id_s_map_chr_len += e_map_chr_len.first + " => " + to_string_(e_map_chr_len.second) + "\n";
        }
        fcout(fn_chr_len, id_s_map_chr_len);

        string id_map_chr_visit_pos = "";
        for (auto i : map_chr_visit_pos)
        {
                id_map_chr_visit_pos += i.first + "\n";
                for (auto j : i.second)
                {
                        id_map_chr_visit_pos += to_string_(j) + ",";
                }
                id_map_chr_visit_pos += "\n";
        }
        fcout(fn_chr_visit_pos, id_map_chr_visit_pos);
}

int CSamParser::get_visit_deepth(const string & chr_name, uint64_t detect_loc)
{
        int deepth_ret = 0;
        uint64_t chr_len = map_chr_len[chr_name];
        assert(chr_len >= detect_loc);
        assert(detect_loc >= 0);

        auto arr_visit_loc = map_chr_visit_pos[chr_name];
        auto len_arr_visit = arr_visit_loc.size();
        uint64_t detect_start = arr_visit_loc[0];
        uint64_t detect_end = arr_visit_loc[len_arr_visit - 1] + CONST_LEN_OF_READ;

        if (detect_end > chr_len)
        {
                detect_end = chr_len;
        }

        if (detect_loc < detect_start || detect_loc > detect_end)
        {
                return deepth_ret;
        }

        else {
                for (auto e_loc_start : arr_visit_loc)
                {
                        if (e_loc_start > detect_loc)
                        {
                                break;
                        }

                        auto e_loc_end = e_loc_start + CONST_LEN_OF_READ;
                        if (e_loc_end > chr_len)
                        {
                                e_loc_end = chr_len;
                        }

                        if (e_loc_start <= detect_loc && detect_loc <= e_loc_end)
                        {
                                deepth_ret++;
                        }
                }
        }

        cout << chr_name << " in loc " << detect_loc << " has visit deepth " << deepth_ret << endl;
        return deepth_ret;
}



CSamParser::CSamParser(const string & fn_sam)
{
        fn = fn_sam;
        read_sam_file_2_two_maps();
        //gen_map_chr_len();
        //gen_map_chr_visit_pos();
}

CSamParser::~CSamParser()
{
}

vector<string> CSamParser::split_str_2_vec(string & str, const char delimiter)
{
        std::vector<std::string>   vec_ret;
        std::stringstream  data(str);

        std::string line;
        while (std::getline(data, line, delimiter))     // assume
        {
                // Note: if multiple delimitor in the source string,
                //           you may see many empty item in vector
                vec_ret.push_back(line);
        }
        return vec_ret;
}


void CSamParser::display_map_chr_len()
{
        for (auto e_chr_len : map_chr_len)
        {
                cout << e_chr_len.first << " => " << e_chr_len.second << endl;
        }
}

void CSamParser::display_map_chr_visit_pos()
{
        for (auto i : map_chr_visit_pos)
        {
                cout << i.first << endl;
                for (auto j : i.second)
                {
                        cout << j << ", ";
                }
                cout << endl << endl;
        }
}

void CSamParser::read_sam_file_2_two_maps()
{
        auto F_R = (ios::in);
        ifstream if_(fn.c_str(), F_R);
        assert(if_.is_open());

        bool flag_meet_pg = false;
        while (!if_.eof())
        {
                //if_.getline(line_content, MAX_CHAR);  // don't need read too long
                std::getline(if_, e_line, '\n');
                if (e_line.size() <= 1)continue;
                auto arr_fields = split_str_2_vec(e_line, '\t');

                // classify to chr len and visit loc

                if (arr_fields[0] == CONST_STR_PG_NO_TAB)
                {
                        flag_meet_pg = true;
                        continue;
                }
                if (false == flag_meet_pg && arr_fields[0] == CONST_STR_SQ_NO_TAB)
                {
                        map_chr_len[arr_fields[1].substr(3)] = (uint64_t)atoi(arr_fields[2].substr(3).c_str());
                }
                else
                {
                        if (!(CONST_INVALID_FLAG == arr_fields[1] || CONST_INVALID_XT_VALUE == arr_fields[11]))
                        {
                                map_chr_visit_pos[arr_fields[2]].push_back(atoi(arr_fields[3].c_str()));
                        }
                }
        }
        if_.close();
#if 1
        throw_map_vect_2_threads_and_run(map_chr_visit_pos);
#endif

#if 0
        for (auto &e_map : map_chr_visit_pos)
        {
                auto& vec_t = e_map.second;             // the "&" is very important here !!!
                std::sort(vec_t.begin(), vec_t.end());
        }
#endif

}

string CSamParser::fcout(const string & fn, const string & id_s)
{
        const auto F_W = (ios::out | ios::trunc);
        ofstream if_(fn.c_str(), F_W);
        if (!if_.is_open()) {
                cout << "- make sure the file path is accessible!" << endl;
        }
        assert(if_.is_open());

        if_ << id_s;
        if_.close();
        //cout << fn << endl;
        return fn;
}


///////////////// jd end class ///////////////

int main() // jd add class
{

        ////////////////////////////////////////
        CSamParser sam_parser(fn);


        //sam_parser.display(3);

#if 1
#ifdef _MSC_VER
        sam_parser.save_map_to_file("E:/jd/t/map_chr_len.txt", "E:/jd/t/map_chr_visit_pos.txt");
#else
        sam_parser.save_map_to_file("./map_chr_len.txt", "./map_chr_visit_pos.txt");
#endif
#endif

        /*
        chr9
        4243687, 14418024, 18894111, 34036842, 34902334, 81513453, 103028956, 113602295, 123115616, 140680084,
        chrX
        21984874, 24996837, 34800528, 35347355, 44948944, 64326215, 76501054, 99810429, 111356763, 125844711, 131145026, 131145026, 132320814,
        */

        //sam_parser.get_visit_deepth("chrX", 131145026 + 4);   // expect 2
        sam_parser.get_visit_deepth("chr15", 20009098 + 1);  // expect 1


        //__P__;
        return 0;
}

# perl reference ref 
#!perl 
use feature qw(say);


my @arr=(
	6666, 4444,
	1,2,3,4); 
my %hash = @arr;  
my $addr_arr = \@arr; 
my $addr_hash = \%hash; 
print $addr_arr->[0] , "\n" ; 

say $addr_hash->{6666} ; 

// c++ getopt usage 
#include <iostream>
#include <unistd.h>
#include <cstdlib>

using namespace std; 

int main( int argc, char* argv[] )
{
	const char* nvalue = "World" ; 
	int tvalue = 1 ;

	int c ;
	while( ( c = getopt (argc, argv, ":n:t:") ) != -1 ) 
	{
		switch(c)
		{
			case 'n':
				if(optarg) nvalue = optarg;
				cout << (char)c << " => " << nvalue <<endl; 
				break;
			case 't':
				if(optarg) tvalue = std::atoi(optarg) ;
				cout << (char)c << " => " << tvalue <<endl; 
				break;
		}
	}

	for( int i = 0 ; i < tvalue; ++i )
		std::cout << '[' << i+1 << "] Hello " << nvalue << "!\n" ;
	std::cout << '\n' ;   
}

/*
g++ test.cpp  && ./a.out -n nv -t 5 
n => nv
t => 5
[1] Hello nv!
[2] Hello nv!
[3] Hello nv!
[4] Hello nv!
[5] Hello nv!
*/


// c++ namespace 
namespace samtools 
{
	vector<string> split_str_2_vec(const string & str);
	vector<sam_record> read_sam_file_2_vec_sam_record(const string & fn);
};


vector<string> samtools::split_str_2_vec(const string & str)
{
	std::vector<std::string>   vec_ret;
	std::stringstream  data(str);

	std::string line;
	while (std::getline(data, line, '\t'))	// assume 
	{
		// Note: if multiple delimitor in the source string, 
		//	     you may see many empty item in vector
		vec_ret.push_back(line);
	}
	return vec_ret;
}

#!perl 

use strict ; 
use feature qw(say);
use List::Util qw(first sum max shuffle maxstr);
use File::Spec::Functions;
use File::Basename qw(dirname basename);

my @arr_fn = qw(
17B029145-1-79.realn.sam
tumor115_target_flank100.bed
1000G_phase1.indels.hg19.vcf
Mills_and_1000G_gold_standard.indels.hg19.vcf 
dbsnp_138.hg19.vcf
); 

my $db = @ENV{'db'}; 


for my $fn_ (@arr_fn)
{
	my $fn = catfile($db, $fn_);
	# print $fn."___" ; 

	if ($fn !~ m/\#/)
	{
		# &sample_small_data($fn);

		&grep_sam_bed_vcf_chr1_100_else_10($fn);
	}
}

# just get some sample 100:10:10 and include the header from a series of files 
sub grep_sam_bed_vcf_chr1_100_else_10($fn)
{

	my $fn = shift;

	my @ret_lines = (); 
	my %hash_chrname = ();
	open my $FP , "<", $fn; 
	my $cnt_all =  -1; 

	my $idx = 0; 
	$idx = 2 if $fn =~ m/\.sam/;
	my $start_save = 0;
	my $inner_cnt = 0;
	my $cnt_r0 = 10;



	while(<$FP>)
	{
		$cnt_all++;	
		my $mul_factor = 1;
		my $e = $_; 
		if ($e =~ m/^\@/ || $e =~ m/^\#/)
		{
			push @ret_lines , $e;
			#print $e;
			next;
		}

		my @t = split m/\t/, $e;
		my $chrname = @t[$idx];

		my $old = keys %hash_chrname;
		@hash_chrname{$chrname}++;
		my $new = keys %hash_chrname;
		
		
		if ($chrname eq "chr1")
		{
			$mul_factor = 10;
		}

		
		
		if ($old != $new)
		{
			$start_save = 1;
			$inner_cnt = 0;
		}

		if ($start_save == 1)
		{

			if ($inner_cnt <= $cnt_r0 * $mul_factor)
			{
				push @ret_lines, $e;
				#print $e;
			}
			else 
			{
				$start_save == 0;
			}
			
			$inner_cnt++;

		}
	}

	close $FP;
	
	open my $FP , ">", q(sample_small_).basename($fn);
	print $FP (join "", @ret_lines);
	close $FP; 

	
	
	
}


if_.seekg(2220);

#perl hash ${ };
	my $hash = 
	{
          '3' => [
                   '4',
                   '3',
                   '0'
                 ],
          '4' => [
                   '1',
                   '3',
                   '2'
                 ],
};

// pthread multithread parallel
#include<iostream>
#include<cstdio>
#include <pthread.h>
#include <vector>

using namespace std;
//pthread_mutex_t m= PTHREAD_MUTEX_INITIALIZER;

static long long total=0;
void* fun(void *p_e)
{
	//pthread_mutex_lock(&m);
	//total += i;
	//pthread_mutex_unlock(&m);

	auto *p_e_ = (int*)p_e;
	p_e_[0] = p_e_[0] * 2;
}

int main(int n_,char ** v_)
{
vector<int> v_i{1,2};
	pthread_t id_thread[55];


	auto len = v_i.size(); 
	auto i = len;
	for (i=0;i<len;i++)
	{
		pthread_create(&id_thread[i],NULL,&fun,&v_i[i]);
	}

	for (i=0;i<len;i++)
	{
		pthread_join(id_thread[i],NULL);
	}


	for (i=0;i<len;i++)
	{
		cout << v_i[i] << endl; 
	}


	return 0;
};

int main()
{
	auto *fn_hg19 = "hg19.fasta0101"; 
	auto *fn_hg19_idx = "hg19.fasta0101.idx";

	ifstream if_(fn_hg19_idx); 
	assert( if_.is_open());
	string e_line;
	while(getline(if_, e_line))
	{
		cout << e_line << endl; 
	}


	if_.close(); 

	return 0;
}


if_.seekg(offset, if_.beg);
 if_.readsome(snp_arr, len);

 // c++ lambda control return fun
auto get_vcf_features = [](char* arr, uint32_t &start, uint32_t &end) -> vector<pair<uint32_t, uint32_t>>

# perl serial to bin from num 
sub serial_arr_2_bin(\@arr)
{
        my $arr_ref = shift;

        for(my $i=0; $i<@$arr_ref; $i++)
        {
                $arr_ref->[$i] = pack("C", $arr_ref->[$i]); 
        }

}

- c++ thread
#include <thread>
        int x = 9;
        int y = 88;
        std::thread td_2(
            [](int &a, int &b)
        {
            cout << a << endl;
            cout << b << endl;
        },
            std::ref(x),
            std::ref(y)
            );
        td_2.join();
-

// cmd parse c++ 

class InputParser {
public:
    InputParser(int &argc, char **argv) {
        for (int i = 1; i < argc; ++i)
            this->tokens.push_back(std::string(argv[i]));
    }
    /// @author iain
    const std::string& getCmdOption(const std::string &option) const {
        std::vector<std::string>::const_iterator itr;
        itr = std::find(this->tokens.begin(), this->tokens.end(), option);
        if (itr != this->tokens.end() && ++itr != this->tokens.end()) {
            return *itr;
        }
        static const std::string empty_string("");
        return empty_string;
    }
    /// @author iain
    bool cmdOptionExists(const std::string &option) const {
        return std::find(this->tokens.begin(), this->tokens.end(), option)
            != this->tokens.end();
    }
private:
    std::vector <std::string> tokens;
};



// st_
int main(int argc, char ** argv)
{
#if 1
    InputParser id_cmd_parse(argc, argv);
    
    cout << id_cmd_parse.cmdOptionExists("-R") << endl;
    cout << id_cmd_parse.getCmdOption("-R") << endl; 
#endif 


// parse cml like : mainapp.exe -R R0 -R R1 -R R2 -L L0
	
class cml_parser
{
public:
    map<string, vector<string>> map_;
    cml_parser(int argc_, char** argv_)
    {
        static vector<string> keys_list{ "-knownSites",  "-R", "-I", "-o", "-L", "-grp" };
        vector<string> vec_arg{};

        auto len = argc_;
        //cout << len << endl;

        for (int i = 0; i < len; i++)
        {
            vec_arg.push_back(string(argv_[i]));
        }

        for (auto &e_key : keys_list)
        {
            vector<string>::iterator it = vec_arg.begin();
            while ((it = std::find(it, vec_arg.end(), e_key)) != vec_arg.end())
            {
                it++;
                map_[e_key].push_back(*it);
                //cout << *it << endl;
            }

        }

    };

    int has_opt(string e_key)
    {
        return map_.find(e_key) == map_.end() ? 0 : 1;
    }
    vector<string> get_arg_opt(string e_key)
    {
        assert(has_opt(e_key));
        return map_[e_key];
    }

};


int main()
{


    
#if 1
    char * argvv[] = {
        "./mainapp.exe",

        "-knownSites", "K0", 
        "-knownSites", "K1", 
        "-knownSites", "K2",
        "-I", "I_V",

        "-o", "o_v", 
        "-L", "L_V",
        "-R", "R_V",
        "-grp", "grp_v",

    };
 
    cml_parser id_cml(17, argvv);

    for (auto &e_map : id_cml.map_)
    {
        cout << e_map.first << endl; 
        for (auto &e_v : e_map.second)
        {
            cout << e_v << " ";
        }
        cout << endl << endl;;
    }


#endif 

