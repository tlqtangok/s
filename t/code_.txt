**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : å®šä¹‰æŽ§åˆ¶å°åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



///////////////////////
**********************
****** save mat ******
**********************
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>


#include <vector>
#include <sstream>

#include <opencv2/opencv.hpp>

typedef unsigned char uchar ; 

using namespace std;
using namespace cv; 




int write_mat(string filename, Mat id_m, int flag=0){
	
	int i=0; 
	int j=0;
	string sb = ""; 
	char buf[100] = {0};
	if ( flag   == 0 ){
	sprintf( buf, "cols = %d ", id_m.cols ); 
	sb += buf; 
	sprintf( buf, "rows = %d", id_m.rows ); 
	sb += buf; 
	sb += "\n"; 
	}
	for(i=0;i<id_m.rows;i++)
	{
		for(j=0;j<id_m.cols;j++){
			unsigned char t = (unsigned char)(id_m.data[i*id_m.step + j]); 
			sprintf(buf, "%d ", t ); 
			sb += buf ; 
						
		}
		sb += "\n"; 
	}
	
	FILE *fp = fopen( filename.c_str() , "w"); 
	fprintf(fp, sb.c_str() ); 
	fclose(fp);
	return 0; 
}

int main(){



int rows = 2; 
int cols = 4;

Mat id_m = Mat(2, 4, CV_8UC1); 

const int len = 2*4; 

uchar buf[len] = {5,6,7,8	,1,2,3,4,}; 



id_m.data = buf ; 







cout <<"- id_m="<< endl<< id_m <<endl ;  

string mat_dat_filename = string("mat.dat");
write_mat(mat_dat_filename, id_m ); 


return 0;
} 
//----------------------------------
typedef unsigned char uchar ;
typedef unsigned char BYTE ;
FILE *fp = NULL; 
int err_no = fopen_s(&fp, filename.c_str(), "rb"); 


char _0 ; 

int cnt_  = 0; 

while ( fread(&_0, 1,1, fp ) == 1 ) {
printf( "%d -> %d \n", cnt_,(BYTE)_0  );  	cnt_++; 	
}
_fcloseall(); 
//-----------------------------------/////////////
void show_id_m(Mat id_m){
   namedWindow("image", CV_WINDOW_AUTOSIZE);  
   imshow("image", id_m);  
   waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

 void clear_img(Mat id_m){
 
    for (int i=0;i<id_m.rows;i++){
       for(int j=0;j<id_m.cols;j++){
         id_m.data[i*id_m.step+j]  = 0; 
       }
   }
 
 }
 ///////
// cv_2.cpp : å®šä¹‰æŽ§åˆ¶å°åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚
//

#include "stdafx.h"
#include <opencv2/opencv.hpp>
#include <math.h>




#include <Windows.h>
#include <iostream>
#include <fstream>

#include <string>
#include <sstream>
#include <vector>
#include <iterator>

using namespace std; 


// typedef unsigned char BYTE; 





using namespace cv; 
extern const unsigned char  buf[] ; 

void clear_img(Mat id_m);
void show_id_m(Mat id_m);

int process_img(Mat id_m, const unsigned char *buf);

//class simple_img 
#define WIDTH_4(w) (w)%4==0?  (w):( (int)( ( (w)+4 )/4 )*4) 
class simple_img{
    /*
    # file content #
    rows = 2;
    cols = 5;
    channels = 1;
    5 6 7 88 5;
    5 6 7 222 7;
    */

    /*
    ///////////////////////////
    string fn= "d:\\jd\\t\\mat.dat"; 
    simple_img id_s =  get_simple_img_from_file( fn );  // need release img data 

    cout<< id_s.tostring()<< endl; 
    id_s.release(); 
    ///////////////////////////
    */

public:
    BYTE *data; 
    int rows; 
    int cols; 
    int step; 
    int channels; 

    simple_img(){}
    simple_img(int rows_,int cols_,int channels_=1){
        data = NULL; 
        rows=rows_;
        cols=cols_;
        channels=channels_;
        step = WIDTH_4(cols);
        data = new BYTE[rows*step*channels];
        assert( data != NULL ); 

    }

    ~simple_img(){

    }

    string tostring(){
        string sb="";
        char buf[111] = {0};
        sprintf_s(buf, "rows = %d;\ncols = %d;\nchannels = %d;\n", rows,cols,channels ); 
        sb += buf; 

        for ( int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                auto &t = data[i*this->step +j];
                if ( j!= cols-1) {sprintf_s(buf,"%d ", t ); }
                else {sprintf_s(buf, "%d;",t);}
                sb += buf; 
            }

            if ( i!=rows-1){sb += "\n"; }
            else {sb += "";}

        }
        return sb; 
    }


    void release(){
        if ( data!=NULL){
            delete [] data; 
            data=NULL; 
        }
    }


};


template<class T> 
vector<T> get_num_arr_from_string(const string& sb){
    // already go sb 
    int i=0;
    int cnt = 0; 
    int start_loc = 0; 
    bool start_flag = false; 
    int end_loc = 0; 
    bool end_flag = false; 



    vector<T> num_arr ; 
    auto *sbb = sb.c_str(); 

    for(auto i: sb){

        if( !start_flag && i>='0' && i<='9' ){

            //printf("%c ",i);

            start_loc = cnt ;
            start_flag = true; 


        }

        if ( start_flag && !(i>='0' && i<='9') ){
            end_loc = cnt ; 
            end_flag = true; 
        }


        if ( end_flag  && start_flag ){
            string id_t(sbb+start_loc, sbb+end_loc); 
            //cout << id_t << endl; 
            num_arr.push_back( (T) atoi(id_t.c_str()) ); 

            start_flag = false ; 
            end_flag = false ; 
        }

        cnt++; 
    }

    if (sizeof(T)==1){
        vector<T> new_num_arr; 
        auto it = num_arr.begin();
        auto it_end = num_arr.end();
        for(int i=0;i<3;i++){it++;}  // we don't need first three as data,they are struct

        new_num_arr.assign(it,num_arr.end());
        return new_num_arr;

    }
    return num_arr ; 

}  // end get_num_arr_from_string(){






simple_img get_simple_img_from_file(string fn){


#define MAX_LINE_CHAR 1024
    ifstream ifs(fn.c_str()); 

    char buf[MAX_LINE_CHAR] ={0}; // each line maxim 


    string sb = "";

    while( !ifs.eof() ){
        ifs.getline(buf, MAX_LINE_CHAR-1); 
        sb += buf; 
        //printf("---%s---\n", buf ); 
    }

    //int rows, cols, channels; 

    ifs.close(); 


    // now , we got sb 

    vector<int> id_struct;  vector<BYTE> id_data; 

    auto sb_begin = sb.substr(0,MAX_LINE_CHAR/4); 
    id_struct = get_num_arr_from_string<int>(sb_begin); 
    id_data= get_num_arr_from_string<BYTE>(sb); 



    int rows = id_struct[0]; 
    int cols = id_struct[1]; 
    int channels = id_struct[2]; 


    // copy data; 
    simple_img id_s = simple_img(rows, cols, channels);
    int cnt =0; 
    for ( int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            auto &t = id_s.data[i*id_s.step +j];
            auto &from = id_data[cnt++];
            t = from; 
        }
    }


    return id_s;

}





Mat get_rectangle_mat(Mat& id_m32, int start_rows,  int end_rows, int start_cols, int end_cols ){

    // end_rows  include!!!
    int rows = id_m32.rows; 

    int cols = id_m32.cols;





    int sz_rows = end_rows - start_rows+1;  // coordinate of end_rows
    int sz_cols = end_cols - start_cols+1; 

    assert( rows>=sz_rows ); 
    assert( cols>=sz_cols ); 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(id_m32.channels())); 

    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    return id_mm; 

}




vector<string> read_file_2_vec_string(string filename){
    vector<string> id_v_str; 
    string sb=""; 
    ifstream ifs(filename.c_str()); 
    const int max_line_sz = 1024; 
    char buf[max_line_sz] = {0};

    while( ifs.getline(buf, max_line_sz)) {

        
        sb=string(buf+0); 
        cout << sb<< endl; 
        id_v_str.push_back(sb);
    }
    return id_v_str; 
}

Mat get_center( Mat id_m32 , int divide_scale = 16 ){

    int rows = id_m32.rows; 

    int cols = id_m32.cols;



    int center_rows = rows/2; 

    int center_cols = cols/2; 

    //int divide_scale = 16; 

    int start_rows = 0 + center_rows - rows/divide_scale; 
    int end_rows = 0 + start_rows + rows/divide_scale*2; 

    int start_cols = 0 + center_cols - cols/divide_scale;
    int end_cols = 0 + start_cols + cols/divide_scale*2; 


    int sz_rows = end_rows - start_rows; 
    int sz_cols = end_cols - start_cols; 


    Mat id_mm(sz_rows,sz_cols, CV_8UC(3)); 





    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &t_from = id_m32.row(i).col(j); 
            auto &t_to = id_mm.row(i-start_rows).col(j-start_cols);

            for (int c=0;c<id_m32.channels();c++){

                t_to.data[c] = t_from.data[c]; 

            }




        }

    } // end for i

    // show_id_m(id_mm);



    return id_mm; 


}



float percent_of_correct_pixels( Mat& id_m32, Mat& id_m64){
    float ret_f = 0.0f;

    //cout << "- into this\n"; 
    assert(id_m32.rows == id_m64.rows); 
    assert(id_m32.cols == id_m64.cols); 
    assert(id_m32.channels() == id_m64.channels()); 


    int start_rows = 0; 
    int end_rows = id_m32.rows; 

    int start_cols= 0; 
    int end_cols = id_m32.cols; 

    int channels = id_m32.channels(); 

    int correct_point_cnt = 0; 



    for(int i=start_rows;i<end_rows; i++){
        for(int j=start_cols;j<end_cols;j++){


            auto &id_t_m32 = id_m32.row(i-start_rows).col(j-start_cols);
            auto &id_t_m64 = id_m64.row(i-start_rows).col(j-start_cols);

            bool flag_equal = true; 

            int cnt_channels = 0; 
            for (int c=0;c<channels;c++){
                if ( id_t_m32.data[c]  == id_t_m64.data[c] ) {cnt_channels++;}
                else { flag_equal = false; break; }

            }

            // cout << "cnt_channels:\n" << cnt_channels <<endl; 

            if ( flag_equal ){
                correct_point_cnt++; 
            }

            // cout << "- correct_point_cnt:\n" << correct_point_cnt << endl ; 
        } // end for j 

    } // end for i

    int all_point_num = end_rows*end_cols; 

    //cout << all_point_num << " ==? "  << correct_point_cnt << endl; 

    if ( all_point_num != correct_point_cnt ){
        printf("all_point_num != correct_point_cnt\n%d ! =%d\n", all_point_num , correct_point_cnt ); 
    }
    ret_f = (float)correct_point_cnt/(float)all_point_num*1.0f; 



    return ret_f; 

}

bool c_is_value_path_c(char c){
    bool ret_t = ( ( c>='0'&& c<='9' ) || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='_') || ( c=='\\') || (c=='/') || (c==':')||(c=='.') ); 
    return ret_t; 
}



vector<string> split_2_words(string& line){

    vector<string> id_word_str ;

    auto *line_c = line.c_str(); 

    auto loc_start = line.find_first_of("<"); 
    auto loc_end = line.find_last_of(">"); 


    string roi_str = string(line_c+loc_start+1, line_c+loc_end ); 

    //cout << "- roi_str"<<roi_str << endl; 

    auto roi_c = roi_str.c_str(); 


    int loc_w_start = 0; 
    int loc_w_end = 0; 

    int flag_start = false ; 

    int flag_end = false ; 



    int cnt =0;
    for ( auto c: roi_str){
        if( !flag_start  && c_is_value_path_c(c) ) {
            flag_start = true; 
            loc_w_start = cnt;

        }

        if( flag_start && !(c_is_value_path_c(c))  ){
            flag_end = true; 
            loc_w_end = cnt ; 

        }

        if ( flag_start && c==roi_c[roi_str.size() - 1] ){
            flag_end = true; 
            loc_w_end = cnt+1; 

        }

        if  (flag_start && flag_end){
            id_word_str.push_back( string(roi_c+loc_w_start, roi_c+loc_w_end) );
            flag_start = false ; 
            flag_end = false; 
        }


        cnt++ ; 
    } // end for 



    printf("\n---start---\n"); 
    for ( auto t: id_word_str ){
        cout << t << endl; 
    }
    return id_word_str; 
}


Mat sub_abs_mat(Mat id_m32, Mat id_m64){
    Mat id_mm = cv::abs(id_m32 - id_m64) ; 
    return id_mm; 

}

void strong_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                if (t[k]!=0) {t[k]=255;}
            }
        }
    }

}



vector<string>  show_img_diff_and_accumuate(Mat& id_m){
    vector<string> id_vec; 

    char buf[111] = {0};

    long long int acc_ret = 0; 
    char *RGB_STR="RGB";
    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                acc_ret += t[k]; 
                char LR_ = '\n';
                if ( t[k]!=0){


                    sprintf_s(buf, "(%d,%d,%c=%d)", i, j ,RGB_STR[k], t[k] );
                    string tstr = string(buf); 
                    id_vec.push_back( tstr ); 
                                      
                   

                }
            }
        }
    } // end for i 
    sprintf_s(buf, "accumuation all is %d", acc_ret ); 
    id_vec.push_back( buf );
    return id_vec; 
}

void print_mat_info(Mat& id_m){
    int rows = id_m.rows; 
    int cols = id_m.cols; 
    cout << "- rows : "<< rows<< endl; 
    cout << "- cols : "<< cols<< endl; 
    cout << "- channels : "<< id_m.channels() << endl << endl; ; 
}



int _tmain(int argc, char** argv)
{


    const int start_rows = 120; 
    const int end_rows = 712; 

    const int start_cols = 188; 
    const int end_cols = 1054 ; 


    auto lines = read_file_2_vec_string( string("X:\\config.txt") ); 


    int cnt_img = 0 ; 
    for ( auto line : lines ){
        if (cnt_img++ > 0 ){break;}
        auto id_word_str = split_2_words( line ); 

        Mat id_m32 = imread(id_word_str[0], IMREAD_COLOR);



        Mat id_m64 = imread(id_word_str[2], IMREAD_COLOR);




        Mat id_rec32 = get_rectangle_mat(id_m32, start_rows,end_rows, start_cols, end_cols); 
        Mat id_rec64 = get_rectangle_mat(id_m64, start_rows,end_rows, start_cols, end_cols); 

        print_mat_info( id_rec32 ); 

        auto rate = percent_of_correct_pixels( id_rec32,  id_rec64); 
        cout << "- rate is "<< rate << endl; 

        auto id_sub_abs_m =  sub_abs_mat(id_rec32,id_rec64);



        vector<string> img_diff_and_acc = show_img_diff_and_accumuate(id_sub_abs_m); 
        
        for (auto i:img_diff_and_acc){
            
            cout << i << endl; 
            
          
        }

       

        


        





        strong_img(id_sub_abs_m);
        show_id_m( id_sub_abs_m );
        waitKey();

        cv::rectangle(id_m64, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m64); 
        waitKey();


        cv::rectangle(id_m32, Rect(start_cols, start_rows, end_cols-start_cols+3, end_rows-start_rows+3), Scalar(20,0,255) );
        show_id_m( id_m32);
        waitKey();


    }  // end for(:)








    waitKey(0); 

    return 0;
} // end main()











/////////////
void show_id_m(Mat id_m){
    namedWindow("image", CV_WINDOW_AUTOSIZE);  
    imshow("image", id_m);  
    // waitKey(0); 
}


int process_img(cv::Mat id_m, const unsigned char *buf){
    auto cols = id_m.cols; 
    auto rows = id_m.rows; 
    int i = 0; 
    int j = 0; 
    for(i=0;i<rows; i++){
        for(j=0;j<cols; j++){
            id_m.data[i*id_m.step+j] = buf[i*id_m.step+j] ;
        }
    }

    return 0;

}

void clear_img(Mat id_m){

    for (int i=0;i<id_m.rows;i++){
        for(int j=0;j<id_m.cols;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=0; 

            }
        }
    }

}



///////

find_by_name '*.cpp' | xargs grep -R  main

/////////////////////
   
   ifstream ifs("X:\\lena512.bmp"); 
   BITMAPFILEHEADER id ; 

   char buf[1024] = {0};
   ifs.read((char*)&id, sizeof(id));


   ifs.close(); 



//////////
// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

     
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();
     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    
   

    return -1; 

    //////////////////////////////////

void clear_img_corner(Mat & id_m){

    for (int i=0;i<id_m.rows/4;i++){
        for(int j=0;j<id_m.cols/3;j++){
            for (int k=0;k< id_m.channels();k++){
                auto t = (id_m.row(i).col(j)).data; 
                t[k]=255; 

            }
        }
    }

}

int _tmain(int argc, char** argv)
{


// cv Filestorage 
// Write and read
// %YAML:1.0
/*
using namespace std; 
using namespace cv; 

id_m: !!opencv-matrix
   rows: 100
   cols: 40
   dt: u
   data: [ 205, 205, 
*/
  /*
    Mat id_m(100,40,CV_8UC(1)); 
    
    FileStorage fs("test.yml", FileStorage::WRITE); 

    fs<< "id_m"<< id_m ; 

    fs.release();

    */ 
    Mat id_mm; 

    FileStorage fsr("test.yml", FileStorage::READ); 
    fsr["id_m"]>> id_mm; 
    fsr.release();



     cout << id_mm.rows << endl ; 
     cout << id_mm.cols << endl; 

     cout << (int)( id_mm.row(3).col(3).data[0] ) << endl;   //205 default 
    

    // clear_img_corner( id_mm ); 

     
     id_mm= id_mm.t();

   imshow("imshow", id_mm ); 
   waitKey(0);


    return -1; 

    //////////////////////////////////
imwrite("test.bmp", id_t); 

int _tmain(int argc, char** argv)
{

    Mat id_t = Mat::zeros(444,444, CV_8UC(1)); 


    int x = 999;
    char buf[111]={0};
    sprintf_s(buf, "%d", x);

    

    putText( id_t, string(buf), Point(id_t.cols/2,id_t.rows/2), 1, 1, Scalar(255) ); 


   // imshow( "id_t", id_t); 

   // imwrite("test.bmp", id_t); 

    int id = 9; 
    id_map[id] = id_t ; 
    id_map[id+1] = id_t; 
    for ( auto tt : id_map ){
    tt.first; 
    auto id_x = tt.second;

    imshow( "id_x", id_x);
    cv::waitKey(0);
    
    }


    



    return -1; 

    //////////////////////////////////
    Mat id_m = imread( "x:\\test_small_50.bmp");
    Mat id_dst_m; 
resize( id_m, id_dst_m, Size(id_m.cols, id_m.rows*(1+3.5/100)), 0, 0, INTER_LINEAR);

Mat id_mm(id_m, Range(1,id_m.rows-20), Range::all()); 
uchar* from_mat_2_pdata(uchar* pData, Mat& id_mt){

    int i=0;
    int j=0;

    int rows_ = id_mt.rows; 
    int cols_ = id_mt.cols;
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            pData[cnt++] = t[0]; 
        }
    }


    return pData;

}

Mat from_pdata_2_mat(uchar* pData, int rows_, int cols_){
    Mat id_mt(rows_, cols_, CV_8UC(1));
    int i=0; int j=0 ; 
    int cnt = 0;
    for(i=0;i<rows_;i++)
    {
        for(j=0;j<cols_;j++)
        {
            auto t = id_mt.row(i).col(j).data; 
            t[0] = pData[cnt++]; 
        }
    }

    return id_mt;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  int to_cut_bottom_len){

    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);


    Mat id_mm(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_bottom_len)); 
    Mat id_dst_m; 
    resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, INTER_LINEAR);

    from_mat_2_pdata(pData, id_dst_m); 
    return pData;
}


uchar* cut_pdata_by_bottom_len(uchar* pData,int rows_, int cols_ ,  bool is_cut_cols_, int to_cut_len){


    double Time = (double)cvGetTickCount();
// ?ã·¨????





    Mat id_mt = from_pdata_2_mat(pData, rows_,cols_);
    Mat id_mm; 
    Mat id_dst_m; 
/*
    enum
{
    INTER_NEAREST=CV_INTER_NN, //!< nearest neighbor interpolation
    INTER_LINEAR=CV_INTER_LINEAR, //!< bilinear interpolation
    INTER_CUBIC=CV_INTER_CUBIC, //!< bicubic interpolation
    INTER_AREA=CV_INTER_AREA, //!< area-based (or super) interpolation
    INTER_LANCZOS4=CV_INTER_LANCZOS4, //!< Lanczos interpolation over 8x8 neighborhood
    INTER_MAX=7,
    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP
};
*/

    
    int interop_way = INTER_NEAREST;
    if ( is_cut_cols_ ){
        
        id_mm = Mat(id_mt, Range(0,id_mt.rows), Range(0,id_mt.cols-to_cut_len)); 
         resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }
    else {
        id_mm = Mat(id_mt, Range(0,id_mt.rows-to_cut_len), Range(0,id_mt.cols)); 
        resize(id_mm, id_dst_m, Size(cols_, rows_), 0,0, interop_way);
    }

   
    from_mat_2_pdata(pData, id_dst_m); 

    Time = (double)cvGetTickCount() - Time ;

    printf( "run time = %gms\n", Time /(cvGetTickFrequency()*1000) );//????
    return pData;
}



Mat  read_bmp_and_T(string str_fn){
    Mat id_m = imread(str_fn); 
    return id_m.t(); 
}


#include <thread>
#include <mutex>
#include <iostream>
using namespace std;
mutex g_mutex;
int g_count = 0;
int main()
{
	thread thr1([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 10;
			}
			});
	thread thr2([]() {
			for (int i = 0;i < 5;i++) {
			lock_guard<mutex> lock(g_mutex); //??
			g_count += 20;
			}
			});
	thr1.join();
	thr2.join();
	cout << g_count << endl;
}
 
*********************
test.cpp
*********************

#include<iostream>
#include<thread>
#include<chrono>
using namespace std;
void fun1(int n) //³õÊ¼»¯¹¹Ôìº¯Êý
{
	cout << "Thread " << n << " executing\n";
	n += 10;
	this_thread::sleep_for(chrono::milliseconds(10));
}
void fun2(int & n) //¿½±´¹¹Ôìº¯Êý
{
	cout << "Thread " << n << " executing\n";
	n += 20;
	this_thread::sleep_for(chrono::milliseconds(10));
}
int main()
{
	int n = 0;
	thread t1; //t1²»ÊÇÒ»¸öthread
	thread t2(fun1, n + 1); //°´ÕÕÖµ´«µÝ
	t2.join();
	cout << "n=" << n << '\n';
	n = 10;
	thread t3(fun2, ref(n)); //ÒýÓÃ
	thread t4(move(t3)); //t4Ö´ÐÐt3£¬t3²»ÊÇthread
	t4.join();
	cout << "n=" <<n << endl;
       	return 0;
}

*********************
compile_by_arm_g++.sh
*********************
ARM_GCC_ROOT=/home/cross/imx6qplus/gcc/gcc-linaro-arm-linux-gnueabihf-4.8-2014.04_linux
#arm-linux-gnueabihf  bin  lib  libexec  share
alias arm_gcc=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-gcc
alias arm_g++=${ARM_GCC_ROOT}/bin/arm-linux-gnueabihf-g++

THIRD_PARTY_DIR=/home/cross/imx6qplus/third_libs_imx6qp
OPENCV_INC=${THIRD_PARTY_DIR}/include
LIB_DIR=${THIRD_PARTY_DIR}/lib
LIB_DIR_QT=/home/cross/imx6qplus/QT/lib
 NAME_OF_LIBS="-lopencv_calib3d -lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lopencv_nonfree -lopencv_objdetect -lopencv_photo -lopencv_stitching -lopencv_superres -lopencv_video -lopencv_videostab"
#export LD_LIBRARY_PATH=${LIB_DIR}:${LIB_DIR_QT}:$LD_LIBRARY_PATH

arm_g++ -std=c++11  -pthread -Wl,-no-as-needed test.cpp  -I${OPENCV_INC} -L${LIB_DIR_QT}  -L${LIB_DIR} 


EOF

